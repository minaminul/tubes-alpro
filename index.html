<!doctype html>
<html lang="id" class="scroll-smooth">
 <head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>MinaMetrics - Professional Land Surveying</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- Added Three.js for optional 3D visualization -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <style>
    :root {
      --bg-primary: #ffffff;
      --bg-secondary: #f8fafc;
      --text-primary: #1e293b;
      --text-secondary: #64748b;
      --border-color: rgba(0, 0, 0, 0.1);
      --glass-bg: rgba(255, 255, 255, 0.8);
      --glass-border: rgba(255, 255, 255, 0.3);
      --accent-primary: #3b82f6;
      --accent-secondary: #0ea5e9;
      --dashed-line-color: #059669;
      --sub-point-color: #10b981;
    }
    
    body.dark-mode {
      --bg-primary: #0d0d0d;
      --bg-secondary: #1e293b;
      --text-primary: #f3f4f6;
      --text-secondary: #cbd5e1;
      --border-color: rgba(255, 255, 255, 0.1);
      --glass-bg: rgba(15, 23, 42, 0.8);
      --glass-border: rgba(255, 255, 255, 0.2);
      --accent-primary: #60a5fa;
      --accent-secondary: #22d3ee;
      --dashed-line-color: #4ade80;
      --sub-point-color: #22c55e;
    }

    * { box-sizing: border-box; }
    body { 
      background-color: var(--bg-primary);
      color: var(--text-primary);
      transition: background-color 0.3s ease, color 0.3s ease;
    }

    .glass {
      background: var(--glass-bg);
      backdrop-filter: blur(20px);
      border: 1px solid var(--glass-border);
    }

    .gradient-bg { background: linear-gradient(135deg, var(--bg-primary) 0%, var(--bg-secondary) 100%); }
    .gradient-text {
      background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .glow-blue { box-shadow: 0 0 20px rgba(59, 130, 246, 0.3); }
    .hover-glow:hover { 
      box-shadow: 0 8px 32px rgba(59, 130, 246, 0.4);
      transform: translateY(-8px);
    }

    .nav-link {
      position: relative;
      transition: all 0.3s ease;
      color: var(--text-primary);
    }

    .nav-link:hover { color: var(--accent-primary); }
    .nav-link::after {
      content: '';
      position: absolute;
      bottom: -4px;
      left: 0;
      width: 0;
      height: 2px;
      background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
      transition: width 0.3s ease;
    }

    .nav-link:hover::after { width: 100%; }

    .fade-in {
      opacity: 0;
      transform: translateY(20px);
      animation: fadeIn 0.8s ease forwards;
    }

    .slide-in-left {
      opacity: 0;
      transform: translateX(-50px);
      animation: slideInLeft 0.8s ease forwards;
    }

    .slide-in-right {
      opacity: 0;
      transform: translateX(50px);
      animation: slideInRight 0.8s ease forwards;
    }

    @keyframes fadeIn { to { opacity: 1; transform: translateY(0); } }
    @keyframes slideInLeft { to { opacity: 1; transform: translateX(0); } }
    @keyframes slideInRight { to { opacity: 1; transform: translateX(0); } }

    .timeline-item { position: relative; padding-left: 2rem; }
    .timeline-item::before {
      content: '';
      position: absolute;
      left: 0;
      top: 0;
      width: 2px;
      height: 100%;
      background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
    }
    .timeline-item-horizontal { position: relative; padding: 1rem; }
    .timeline-year {
      background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
      color: white;
      padding: 0.5rem 1rem;
      border-radius: 0.5rem;
      font-weight: bold;
      display: inline-block;
      margin-bottom: 0.5rem;
    }

    .btn-gradient {
      background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
      transition: all 0.3s ease;
      color: white;
    }

    .btn-gradient:hover {
      transform: scale(1.05);
      box-shadow: 0 8px 25px rgba(59, 130, 246, 0.4);
    }

    .btn-glass {
      background: var(--glass-bg);
      backdrop-filter: blur(20px);
      border: 1px solid var(--glass-border);
      transition: all 0.3s ease;
      color: var(--text-primary);
    }

    .btn-glass:hover {
      background: rgba(255, 255, 255, 0.3);
      transform: scale(1.05);
    }

    .section-heading {
      position: relative;
      text-align: center;
      margin-bottom: 3rem;
      color: var(--text-primary);
    }

    .section-heading::after {
      content: '';
      position: absolute;
      bottom: -10px;
      left: 50%;
      transform: translateX(-50%);
      width: 60px;
      height: 3px;
      background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
      border-radius: 2px;
    }

    .surveyor-tab {
      transition: all 0.3s ease;
      border-bottom: 3px solid transparent;
      color: var(--text-primary);
    }

    .surveyor-tab.active {
      background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
      color: white;
      border-bottom-color: var(--accent-secondary);
    }

    .surveyor-tab:hover:not(.active) {
      background: rgba(59, 130, 246, 0.1);
      color: var(--accent-primary);
    }

    .polygon-tab {
      transition: all 0.3s ease;
      border-bottom: 2px solid transparent;
      color: var(--text-primary);
    }

    .polygon-tab.active {
      border-bottom-color: var(--accent-primary);
      color: var(--accent-primary);
    }

    .result-box {
      background: linear-gradient(135deg, rgba(219, 234, 254, 0.5), rgba(191, 219, 254, 0.5));
      border: 2px solid var(--accent-primary);
      color: var(--text-primary);
    }

    body.dark-mode .result-box {
      background: linear-gradient(135deg, rgba(30, 58, 138, 0.5), rgba(23, 37, 84, 0.5));
    }

    #mobile-menu {
      transform: translateX(100%);
      transition: transform 0.3s ease;
    }

    #mobile-menu.active {
      transform: translateX(0);
    }
    
    /* Responsive design untuk mobile dan desktop */
    @media (max-width: 768px) {
      body { font-size: 14px; }
      .section-heading { margin-bottom: 2rem; }
      #mobile-menu { width: 100%; }
    }
    
    /* Dark mode toggle button styling */
    .theme-toggle {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      padding: 0.5rem 1rem;
      background: var(--glass-bg);
      border: 2px solid var(--glass-border);
      border-radius: 0.5rem;
      cursor: pointer;
      transition: all 0.3s ease;
      color: var(--text-primary);
      font-size: 1.2rem;
      font-weight: 600;
    }
    
    .theme-toggle:hover {
      background: var(--bg-secondary);
      transform: scale(1.05);
      border-color: var(--accent-primary);
    }

    /* Add desktop theme toggle button styling */
    .desktop-theme-toggle {
      display: none;
      align-items: center;
      gap: 0.5rem;
      padding: 0.5rem 1rem;
      background: var(--glass-bg);
      border: 2px solid var(--glass-border);
      border-radius: 0.5rem;
      cursor: pointer;
      transition: all 0.3s ease;
      color: var(--text-primary);
      font-size: 1.2rem;
      font-weight: 600;
    }
    
    .desktop-theme-toggle:hover {
      background: var(--bg-secondary);
      transform: scale(1.05);
      border-color: var(--accent-primary);
    }

    @media (min-width: 768px) {
      .desktop-theme-toggle {
        display: flex;
      }
    }

    /* Improved contour visualization with proper legend styling */
    .contour-legend {
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
      font-size: 0.9rem;
      padding: 1rem;
      background: var(--bg-primary);
      border-radius: 0.5rem;
      border: 2px solid var(--border-color);
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    }

    .contour-legend-item {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      padding: 0.25rem 0;
      color: var(--text-primary);
    }

    .contour-legend-color {
      width: 24px;
      height: 24px;
      border-radius: 3px;
      border: 2px solid var(--border-color);
    }

    /* SVG canvas styling for better visibility */
    #polygon-preview svg,
    #grid-preview svg,
    #random-preview svg {
      background: var(--bg-primary);
      border: 2px solid var(--border-color);
      border-radius: 0.5rem;
    }

    /* Input styling for consistency */
    input[type="text"],
    input[type="email"],
    input[type="number"],
    textarea,
    select {
      padding: 0.75rem 1rem; /* Slightly larger padding */
      border: 2px solid var(--border-color); /* Thicker border */
      border-radius: 0.375rem; /* Rounded corners */
      transition: all 0.3s ease;
      color: var(--text-primary);
      background-color: var(--bg-secondary);
    }

    input:focus, textarea:focus, select:focus {
      border-color: var(--accent-primary);
      box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.3); /* Focus ring */
      background-color: var(--bg-primary);
      outline: none;
    }

    /* Added CSS for contour visualization and 3D mode */
    #canvas-3d {
      width: 100% !important;
      height: 400px !important;
      border: 1px solid var(--border-color);
      border-radius: 0.5rem;
      display: none; /* Initially hidden */
    }

    #canvas-3d.active {
      display: block;
    }

    .hidden { display: none; }

    /* Mode toggle button styling */
    .mode-toggle-btn {
        padding: 0.5rem 1rem;
        border-radius: 0.375rem;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.3s ease;
        margin-bottom: 0.5rem;
        border: 1px solid transparent;
    }

    .mode-toggle-btn.active {
        background-color: #3b82f6;
        color: white;
        border-color: #3b82f6;
    }

    .mode-toggle-btn:not(.active) {
        background-color: var(--bg-secondary); /* Use secondary background for non-active */
        color: var(--text-primary);
        border-color: var(--border-color);
    }
    .mode-toggle-btn:not(.active):hover {
        background-color: var(--bg-primary); /* Slightly darker on hover */
        border-color: var(--accent-primary);
        color: var(--accent-primary);
    }
  </style>
  <style>@view-transition: navigation: auto; </style>
  <script src="/_sdk/data_sdk.js" type="text/javascript"></script>
 </head>
 <body class="gradient-bg min-h-full">
  <!-- Navbar -->
  <nav class="fixed top-0 w-full z-50 glass">
   <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
    <div class="flex justify-between items-center h-16">
     <div class="flex-shrink-0">
      <h1 class="text-2xl font-bold gradient-text" id="brand-name">MinaMetrics</h1>
     </div><!-- Desktop Menu -->
     <div class="hidden md:block">
      <div class="ml-10 flex items-baseline space-x-8"><button onclick="navigateToPage('home')" class="nav-link px-3 py-2 text-sm font-medium">Beranda</button> <button onclick="navigateToPage('about')" class="nav-link px-3 py-2 text-sm font-medium">Tentang</button> <button onclick="navigateToPage('services')" class="nav-link px-3 py-2 text-sm font-medium">Layanan</button> <button onclick="navigateToPage('calculator')" class="nav-link px-3 py-2 text-sm font-medium">Kalkulator</button> <button onclick="navigateToPage('partner')" class="nav-link px-3 py-2 text-sm font-medium">Partner</button> <button onclick="navigateToPage('contact')" class="nav-link px-3 py-2 text-sm font-medium">Kontak</button>
      </div>
     </div><!-- Mobile menu button -->
     <div class="md:hidden flex items-center gap-2">
        <button id="theme-toggle-btn" class="theme-toggle">
            <span id="theme-icon">‚òÄÔ∏è</span>
        </button>
        <button id="mobile-menu-btn" class="text-gray-700 hover:text-blue-600">
            <svg class="h-6 w-6" fill="none" viewbox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16" />
            </svg>
        </button>
     </div>
     <!-- Add desktop theme toggle button in navbar -->
     <button class="desktop-theme-toggle">
         <span id="theme-icon-desktop">‚òÄÔ∏è</span>
     </button>
    </div>
   </div>
   <!-- Mobile Menu -->
   <div id="mobile-menu" class="md:hidden fixed top-16 right-0 w-64 h-full glass">
    <div class="px-2 pt-2 pb-3 space-y-1"><button onclick="navigateToPage('home')" class="block w-full text-left px-3 py-2">Beranda</button> <button onclick="navigateToPage('about')" class="block w-full text-left px-3 py-2">Tentang</button> <button onclick="navigateToPage('services')" class="block w-full text-left px-3 py-2">Layanan</button> <button onclick="navigateToPage('calculator')" class="block w-full text-left px-3 py-2">Kalkulator</button> <button onclick="navigateToPage('partner')" class="block w-full text-left px-3 py-2">Partner</button> <button onclick="navigateToPage('contact')" class="block w-full text-left px-3 py-2">Kontak</button>
    </div>
   </div>
  </nav><!-- Main Content Container -->
  <div class="pt-20 min-h-screen"><!-- Page Content Area -->
   <div class="w-full" id="page-content"><!-- Home Page (Default) -->
    <div id="home-page" class="page-content">
     <section class="min-h-screen p-8">
      <div class="max-w-6xl mx-auto"><!-- Hero Area -->
       <div class="grid grid-cols-1 lg:grid-cols-2 gap-12 items-center mb-16"><!-- Left Column -->
        <div class="slide-in-left">
         <p class="text-blue-600 font-semibold mb-4" id="hero-tagline">Teknologi Survey Terdepan</p>
         <h1 class="text-4xl lg:text-5xl font-bold mb-6" id="hero-title">Solusi Survey Profesional untuk Masa Depan</h1>
         <p class="text-lg mb-8" id="hero-description">Dengan teknologi terdepan dan tim berpengalaman, kami memberikan layanan survey topografi, pemetaan GPS, dan analisis kontur yang akurat untuk proyek konstruksi dan infrastruktur Anda.</p>
         <div class="flex flex-col sm:flex-row gap-4"><button onclick="navigateToPage('contact')" class="btn-gradient text-white px-8 py-3 rounded-lg font-semibold">Konsultasi Gratis</button> <button onclick="navigateToPage('services')" class="btn-glass text-gray-700 px-8 py-3 rounded-lg font-semibold">Lihat Layanan</button>
         </div>
        </div><!-- Right Column - SVG Illustration -->
        <div class="slide-in-right">
         <svg viewbox="0 0 400 300" class="w-full h-auto"><!-- Background --> <defs>
           <lineargradient id="skyGradient" x1="0%" y1="0%" x2="0%" y2="100%">
            <stop offset="0%" style="stop-color:#7dd3fc;stop-opacity:0.3" />
            <stop offset="100%" style="stop-color:#3b82f6;stop-opacity:0.1" />
           </lineargradient>
           <lineargradient id="equipmentGradient" x1="0%" y1="0%" x2="100%" y2="100%">
            <stop offset="0%" style="stop-color:#3b82f6" />
            <stop offset="100%" style="stop-color:#0ea5e9" />
           </lineargradient>
          </defs> <!-- Sky --> <rect width="400" height="150" fill="url(#skyGradient)" /> <!-- Ground --> <path d="M0 150 Q100 140 200 145 T400 150 L400 300 L0 300 Z" fill="#10b981" opacity="0.3" /> <path d="M0 160 Q150 150 300 155 T400 160 L400 300 L0 300 Z" fill="#059669" opacity="0.2" /> <!-- Survey Equipment (Total Station) --> <g transform="translate(180, 120)"><!-- Tripod -->
           <line x1="0" y1="30" x2="-25" y2="80" stroke="url(#equipmentGradient)" stroke-width="3" />
           <line x1="0" y1="30" x2="25" y2="80" stroke="url(#equipmentGradient)" stroke-width="3" />
           <line x1="0" y1="30" x2="0" y2="80" stroke="url(#equipmentGradient)" stroke-width="3" /> <!-- Equipment Body -->
           <rect x="-15" y="10" width="30" height="20" fill="url(#equipmentGradient)" rx="3" />
           <circle cx="0" cy="20" r="8" fill="#0ea5e9" />
           <circle cx="0" cy="20" r="4" fill="#ffffff" /> <!-- Telescope -->
           <rect x="-20" y="17" width="40" height="6" fill="url(#equipmentGradient)" rx="3" />
          </g> <!-- Survey Markers --> <g fill="url(#equipmentGradient)">
           <circle cx="80" cy="180" r="4" />
           <rect x="76" y="160" width="8" height="20" />
           <circle cx="320" cy="170" r="4" />
           <rect x="316" y="150" width="8" height="20" />
           <circle cx="150" cy="190" r="4" />
           <rect x="146" y="170" width="8" height="20" />
          </g> <!-- Measurement Lines --> <g stroke="#3b82f6" stroke-width="2" stroke-dasharray="5,5" opacity="0.7">
           <line x1="80" y1="180" x2="180" y2="150" />
           <line x1="180" y1="150" x2="320" y2="170" />
           <line x1="320" y1="170" x2="150" y2="190" />
          </g> <!-- Elevation Lines --> <g stroke="#0ea5e9" stroke-width="1" opacity="0.5">
           <path d="M50 200 Q150 190 250 195 T350 200" fill="none" />
           <path d="M50 210 Q150 200 250 205 T350 210" fill="none" />
           <path d="M50 220 Q150 210 250 215 T350 220" fill="none" />
          </g> <!-- Distance Labels --> <g fill="#3b82f6" font-family="Arial" font-size="10" text-anchor="middle">
           <text x="130" y="165">125.5m</text>
           <text x="250" y="155">89.2m</text>
           <text x="235" y="185">156.8m</text>
          </g>
         </svg>
        </div>
       </div><!-- Company Overview -->
       <div class="grid grid-cols-1 md:grid-cols-2 gap-8 mb-12">
        <div class="glass rounded-2xl p-8 fade-in">
         <h3 class="text-2xl font-bold mb-4">Tentang MinaMetrics</h3>
         <p class="text-gray-600 mb-4">Perusahaan survey dan pemetaan profesional yang telah berpengalaman lebih dari 6 tahun dalam memberikan solusi geospasial terdepan untuk berbagai proyek infrastruktur di Indonesia.</p>
         <p class="text-gray-600">Dengan tim ahli bersertifikat dan teknologi modern, kami berkomitmen memberikan hasil survey yang akurat dan tepat waktu.</p>
        </div>
        <div class="glass rounded-2xl p-8 fade-in">
         <h3 class="text-2xl font-bold mb-4">Mengapa Memilih Kami?</h3>
         <ul class="space-y-3">
          <li class="flex items-start">
           <div class="w-2 h-2 bg-blue-500 rounded-full mt-2 mr-3 flex-shrink-0"></div><span class="text-gray-700">Akurasi tinggi dengan teknologi GPS RTK</span></li>
          <li class="flex items-start">
           <div class="w-2 h-2 bg-blue-500 rounded-full mt-2 mr-3 flex-shrink-0"></div><span class="text-gray-700">Tim surveyor bersertifikat internasional</span></li>
          <li class="flex items-start">
           <div class="w-2 h-2 bg-blue-500 rounded-full mt-2 mr-3 flex-shrink-0"></div><span class="text-gray-700">Pengalaman 100+ proyek sukses</span></li>
          <li class="flex items-start">
           <div class="w-2 h-2 bg-blue-500 rounded-full mt-2 mr-3 flex-shrink-0"></div><span class="text-gray-700">Layanan konsultasi gratis</span></li>
         </ul>
        </div>
       </div><!-- Quick Features -->
       <div class="grid grid-cols-1 md:grid-cols-3 gap-8"><!-- Survey Akurat -->
        <div class="glass rounded-2xl p-8 text-center hover-glow transition-all duration-300 fade-in cursor-pointer" onclick="navigateToPage('services')">
         <div class="w-16 h-16 mx-auto mb-6 rounded-full bg-gradient-to-r from-blue-500 to-cyan-500 flex items-center justify-center">
          <svg class="w-8 h-8 text-white" fill="none" stroke="currentColor" viewbox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 20l-5.447-2.724A1 1 0 013 16.382V5.618a1 1 0 011.447-.894L9 7m0 13l6-3m-6 3V7m6 10l4.553 2.276A1 1 0 0021 18.382V7.618a1 1 0 00-1.447-.894L15 4m0 13V4m0 0L9 7" />
          </svg>
         </div>
         <h3 class="text-xl font-bold mb-4">Survey Akurat</h3>
         <p class="text-gray-600">Teknologi GPS RTK dengan akurasi hingga centimeter untuk hasil survey yang presisi.</p>
        </div><!-- Kalkulator Online -->
        <div class="glass rounded-2xl p-8 text-center hover-glow transition-all duration-300 fade-in cursor-pointer" style="animation-delay: 0.2s;" onclick="navigateToPage('calculator')">
         <div class="w-16 h-16 mx-auto mb-6 rounded-full bg-gradient-to-r from-blue-500 to-cyan-500 flex items-center justify-center">
          <svg class="w-8 h-8 text-white" fill="none" stroke="currentColor" viewbox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 7h6m0 10v-3m-3 3h.01M9 17h.01M9 14h.01M12 14h.01M15 11h.01M12 11h.01M9 11h.01M7 21h10a2 2 0 002-2V5a2 2 0 00-2-2H7a2 2 0 00-2 2v14a2 2 0 002 2z" />
          </svg>
         </div>
         <h3 class="text-xl font-bold mb-4">Kalkulator Online</h3>
         <p class="text-gray-600">Tools perhitungan jarak, luas, dan volume tanah yang mudah digunakan dan akurat.</p>
        </div><!-- Konsultasi Gratis -->
        <div class="glass rounded-2xl p-8 text-center hover-glow transition-all duration-300 fade-in cursor-pointer" style="animation-delay: 0.4s;" onclick="navigateToPage('contact')">
         <div class="w-16 h-16 mx-auto mb-6 rounded-full bg-gradient-to-r from-blue-500 to-cyan-500 flex items-center justify-center">
          <svg class="w-8 h-8 text-white" fill="none" stroke="currentColor" viewbox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 12h.01M12 12h.01M16 12h.01M21 12c0 4.418-4.03 8-9 8a9.863 9.863 0 01-4.255-.949L3 20l1.395-3.72C3.512 15.042 3 13.574 3 12c0-4.418 4.03-8 9-8s9 3.582 9 8z" />
          </svg>
         </div>
         <h3 class="text-xl font-bold mb-4">Konsultasi Gratis</h3>
         <p class="text-gray-600">Dapatkan konsultasi gratis untuk kebutuhan survey proyek Anda dari tim ahli kami.</p>
        </div>
       </div>
      </div>
     </section>
    </div><!-- About Page -->
    <div id="about-page" class="page-content hidden">
     <section class="min-h-screen p-8">
      <div class="max-w-6xl mx-auto">
       <h2 class="text-4xl font-bold mb-12 text-center">Tentang MinaMetrics</h2>
       <div class="glass rounded-2xl p-12 mb-12 fade-in">
        <h3 class="text-2xl font-bold mb-6">Sejarah Perusahaan</h3>
        <div class="space-y-6">
         <div class="timeline-item">
          <div class="timeline-year">2018</div>
          <p class="text-gray-600">MinaMetrics didirikan sebagai perusahaan survey profesional dengan fokus pada teknologi geospasial modern.</p>
         </div>
         <div class="timeline-item">
          <div class="timeline-year">2019</div>
          <p class="text-gray-600">Ekspansi ke layanan pemetaan GPS RTK dan analisis kontur untuk proyek infrastruktur besar.</p>
         </div>
         <div class="timeline-item">
          <div class="timeline-year">2021</div>
          <p class="text-gray-600">Pengembangan platform online untuk kalkulator survey dan analisis data geospasial.</p>
         </div>
         <div class="timeline-item">
          <div class="timeline-year">2024</div>
          <p class="text-gray-600">Meluncurkan MinaMetrics Web App dengan fitur perhitungan poligon, grid, dan profil online.</p>
         </div>
        </div>
       </div>
       <div class="grid grid-cols-1 md:grid-cols-3 gap-8">
        <div class="glass rounded-2xl p-8 text-center fade-in">
         <div class="text-4xl font-bold text-blue-600 mb-2">50+</div>
         <p class="text-gray-700 font-semibold">Tim Profesional</p>
         <p class="text-gray-600 text-sm mt-2">Surveyor bersertifikat internasional</p>
        </div>
        <div class="glass rounded-2xl p-8 text-center fade-in" style="animation-delay: 0.2s;">
         <div class="text-4xl font-bold text-blue-600 mb-2">100+</div>
         <p class="text-gray-700 font-semibold">Proyek Selesai</p>
         <p class="text-gray-600 text-sm mt-2">Kepuasan klien 99%</p>
        </div>
        <div class="glass rounded-2xl p-8 text-center fade-in" style="animation-delay: 0.4s;">
         <div class="text-4xl font-bold text-blue-600 mb-2">6+</div>
         <p class="text-gray-700 font-semibold">Tahun Berpengalaman</p>
         <p class="text-gray-600 text-sm mt-2">Di industri geospasial</p>
        </div>
       </div>
      </div>
     </section>
    </div><!-- Services Page -->
    <div id="services-page" class="page-content hidden">
     <section class="min-h-screen p-8">
      <div class="max-w-6xl mx-auto">
       <h2 class="text-4xl font-bold mb-12 text-center">Layanan Kami</h2>
       <div class="grid grid-cols-1 md:grid-cols-2 gap-8 mb-12">
        <div class="glass rounded-2xl p-8 hover-glow cursor-pointer fade-in">
         <div class="w-12 h-12 rounded-lg bg-gradient-to-r from-blue-500 to-cyan-500 flex items-center justify-center mb-6">
          <svg class="w-6 h-6 text-white" fill="none" stroke="currentColor" viewbox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 20l-5.447-2.724A1 1 0 013 16.382V5.618a1 1 0 011.447-.894L9 7m0 13l6-3m-6 3V7m6 10l4.553 2.276A1 1 0 0021 18.382V7.618a1 1 0 00-1.447-.894L15 4m0 13V4m0 0L9 7" />
          </svg>
         </div>
         <h3 class="text-2xl font-bold mb-4">Survey Topografi</h3>
         <p class="text-gray-600 mb-4">Pemetaan detail kontur tanah dengan teknologi GPS RTK presisi tinggi untuk proyek konstruksi dan infrastruktur.</p>
         <ul class="space-y-2 text-sm text-gray-700">
          <li class="flex items-center"><span class="w-2 h-2 bg-blue-500 rounded-full mr-2"></span>Akurasi hingga 2cm</li>
          <li class="flex items-center"><span class="w-2 h-2 bg-blue-500 rounded-full mr-2"></span>Pemetaan area besar</li>
          <li class="flex items-center"><span class="w-2 h-2 bg-blue-500 rounded-full mr-2"></span>Laporan detail</li>
         </ul>
        </div>
        <div class="glass rounded-2xl p-8 hover-glow cursor-pointer fade-in" style="animation-delay: 0.2s;">
         <div class="w-12 h-12 rounded-lg bg-gradient-to-r from-blue-500 to-cyan-500 flex items-center justify-center mb-6">
          <svg class="w-6 h-6 text-white" fill="none" stroke="currentColor" viewbox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 7h6m0 10v-3m-3 3h.01M9 17h.01M9 14h.01M12 14h.01M15 11h.01M12 11h.01M9 11h.01M7 21h10a2 2 0 002-2V5a2 2 0 00-2-2H7a2 2 0 00-2 2v14a2 2 0 002 2z" />
          </svg>
         </div>
         <h3 class="text-2xl font-bold mb-4">Pemetaan GPS</h3>
         <p class="text-gray-600 mb-4">Pengukuran koordinat presisi untuk penetapan batas wilayah, landmark, dan titik referensi penting.</p>
         <ul class="space-y-2 text-sm text-gray-700">
          <li class="flex items-center"><span class="w-2 h-2 bg-blue-500 rounded-full mr-2"></span>Teknologi RTK terbaru</li>
          <li class="flex items-center"><span class="w-2 h-2 bg-blue-500 rounded-full mr-2"></span>Real-time processing</li>
          <li class="flex items-center"><span class="w-2 h-2 bg-blue-500 rounded-full mr-2"></span>Sertifikat resmi</li>
         </ul>
        </div>
        <div class="glass rounded-2xl p-8 hover-glow cursor-pointer fade-in" style="animation-delay: 0.4s;">
         <div class="w-12 h-12 rounded-lg bg-gradient-to-r from-blue-500 to-cyan-500 flex items-center justify-center mb-6">
          <svg class="w-6 h-6 text-white" fill="none" stroke="currentColor" viewbox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z" />
          </svg>
         </div>
         <h3 class="text-2xl font-bold mb-4">Analisis Kontur</h3>
         <p class="text-gray-600 mb-4">Analisis elevasi dan kemiringan lahan untuk perencanaan proyek sipil dan pengelolaan lingkungan.</p>
         <ul class="space-y-2 text-sm text-gray-700">
          <li class="flex items-center"><span class="w-2 h-2 bg-blue-500 rounded-full mr-2"></span>Peta kontur 3D</li>
          <li class="flex items-center"><span class="w-2 h-2 bg-blue-500 rounded-full mr-2"></span>Analisis drainase</li>
          <li class="flex items-center"><span class="w-2 h-2 bg-blue-500 rounded-full mr-2"></span>Volume earthwork</li>
         </ul>
        </div>
        <div class="glass rounded-2xl p-8 hover-glow cursor-pointer fade-in" style="animation-delay: 0.6s;">
         <div class="w-12 h-12 rounded-lg bg-gradient-to-r from-blue-500 to-cyan-500 flex items-center justify-center mb-6">
          <svg class="w-6 h-6 text-white" fill="none" stroke="currentColor" viewbox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z" />
          </svg>
         </div>
         <h3 class="text-2xl font-bold mb-4">Konsultasi Teknis</h3>
         <p class="text-gray-600 mb-4">Konsultasi profesional untuk perencanaan survey, interpretasi data, dan solusi geospasial.</p>
         <ul class="space-y-2 text-sm text-gray-700">
          <li class="flex items-center"><span class="w-2 h-2 bg-blue-500 rounded-full mr-2"></span>Tim ahli berpengalaman</li>
          <li class="flex items-center"><span class="w-2 h-2 bg-blue-500 rounded-full mr-2"></span>Gratis untuk klien baru</li>
          <li class="flex items-center"><span class="w-2 h-2 bg-blue-500 rounded-full mr-2"></span>Support 24/7</li>
         </ul>
        </div>
       </div>
      </div>
     </section>
    </div><!-- Calculator Page -->
    <div id="calculator-page" class="page-content hidden">
     <section class="min-h-screen p-8">
      <div class="max-w-7xl mx-auto">
       <h2 class="text-3xl font-bold mb-12 text-center">Kalkulator Surveyor &amp; Kontur</h2>
       <div class="glass rounded-2xl p-8 fade-in"><!-- Navigation Tabs -->
        <div class="flex flex-wrap justify-center mb-8 border-b border-gray-200"><button class="surveyor-tab active px-6 py-3 font-semibold rounded-t-lg transition-all duration-300" data-tab="polygon">
          <svg class="w-5 h-5 inline-block mr-2" fill="none" stroke="currentColor" viewbox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 20l-5.447-2.724A1 1 0 013 16.382V5.618a1 1 0 011.447-.894L9 7m0 13l6-3m-6 3V7m6 10l4.553 2.276A1 1 0 0021 18.382V7.618a1 1 0 00-1.447-.894L15 4m0 13V4m0 0L9 7" />
          </svg> Poligon </button> <button class="surveyor-tab px-6 py-3 font-semibold rounded-t-lg transition-all duration-300" data-tab="grid">
          <svg class="w-5 h-5 inline-block mr-2" fill="none" stroke="currentColor" viewbox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 5a1 1 0 011-1h14a1 1 0 011 1v2a1 1 0 01-1 1H5a1 1 0 01-1-1V5zM4 13a1 1 0 011-1h6a1 1 0 011 1v6a1 1 0 01-1 1H5a1 1 0 01-1-1v-6zM16 13a1 1 0 011-1h2a1 1 0 011 1v6a1 1 0 01-1 1h-2a1 1 0 01-1-1v-6z" />
          </svg> Grid </button> <button class="surveyor-tab px-6 py-3 font-semibold rounded-t-lg transition-all duration-300" data-tab="profile">
          <svg class="w-5 h-5 inline-block mr-2" fill="none" stroke="currentColor" viewbox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z" />
          </svg> Profil/Transek </button> <button class="surveyor-tab px-6 py-3 font-semibold rounded-t-lg transition-all duration-300" data-tab="random">
          <svg class="w-5 h-5 inline-block mr-2" fill="none" stroke="currentColor" viewbox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17.657 16.657L13.414 20.9a1.998 1.998 0 01-2.827 0l-4.244-4.243a8 8 0 1111.314 0z" /> <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 11a3 3 0 11-6 0 3 3 0 016 0z" />
          </svg> Titik Acak </button>
        </div><!-- Polygon Module - SISTEM LENGKAP SESUAI REQUIREMENT -->
        <div id="polygon-calc" class="surveyor-content">
         <div class="grid grid-cols-1 xl:grid-cols-3 gap-8"><!-- Input Section -->
          <div class="xl:col-span-1">
           <h3 class="text-xl font-bold mb-6">Input Data Poligon</h3><!-- Tab untuk Main Points dan Sub Points -->
           <div class="flex mb-4 border-b border-gray-200"><button id="main-point-tab" class="polygon-tab active px-4 py-2 font-semibold" onclick="switchPolygonTab('main')">Titik Utama</button> <button id="sub-point-tab" class="polygon-tab px-4 py-2 font-semibold" onclick="switchPolygonTab('sub')">Titik Turunan</button>
           </div><!-- Input Titik Utama (A, B, C... dengan X, Y, Z) -->
           <div id="main-point-input" class="space-y-4 mb-6">
            <div class="bg-blue-50 p-3 rounded-lg text-sm text-blue-700"><strong>Titik Utama:</strong> Huruf besar (A, B, C...) dengan X, Y, dan Z (elevasi)
            </div>
            <div class="grid grid-cols-2 gap-2"><input type="text" placeholder="Nama (A,B,C...)" maxlength="1" pattern="[A-Z]" class="p-3 border border-gray-300 rounded-lg polygon-main-name" style="text-transform: uppercase;"> <input type="number" placeholder="X (m)" step="0.001" class="p-3 border border-gray-300 rounded-lg polygon-main-x">
            </div>
            <div class="grid grid-cols-2 gap-2"><input type="number" placeholder="Y (m)" step="0.001" class="p-3 border border-gray-300 rounded-lg polygon-main-y"> <input type="number" placeholder="Z (m)" step="0.001" class="p-3 border border-gray-300 rounded-lg polygon-main-z">
            </div><button onclick="addMainPoint()" class="w-full btn-gradient text-white px-4 py-2 rounded-lg font-semibold">Tambah Titik Utama</button>
           </div><!-- Input Titik Turunan (3 Metode) -->
           <div id="sub-point-input" class="space-y-4 mb-6 hidden">
            <div class="bg-green-50 p-3 rounded-lg text-sm text-green-700"><strong>Titik Turunan:</strong> Dari titik utama dengan 3 metode
            </div><!-- Method Selection -->
            <div class="grid grid-cols-3 gap-2"><button id="method-angle" class="px-3 py-2 rounded-lg font-semibold border-2 border-blue-500 bg-blue-50 text-blue-700" onclick="selectSubMethod('angle')">Œ±</button> <button id="method-distance" class="px-3 py-2 rounded-lg font-semibold border-2 border-gray-300 text-gray-700" onclick="selectSubMethod('distance')">Œ¥</button> <button id="method-height" class="px-3 py-2 rounded-lg font-semibold border-2 border-gray-300 text-gray-700" onclick="selectSubMethod('height')">Z</button>
            </div>
            <!-- Method 1: Angle + Distance -->
            <div id="method-angle-input" class="space-y-3">
             <select class="w-full p-3 border border-gray-300 rounded-lg polygon-sub-main"><option value="">Pilih Titik Utama</option></select>
             <input type="text" placeholder="Nama (a1, b1...)" class="w-full p-3 border border-gray-300 rounded-lg polygon-sub-name">
             <!-- Split into separate divs for better control and conditional display -->
             <div id="angle-input-section">
              <label class="text-sm font-semibold text-gray-700 block mb-1">Sudut (¬∞)</label>
              <input type="number" placeholder="Masukkan sudut‚Ä¶" step="0.01" min="0" max="360" class="w-full p-3 border border-gray-300 rounded-lg polygon-sub-angle" id="input-angle-value">
             </div>
             <div id="distance-input-section" class="hidden">
              <label class="text-sm font-semibold text-gray-700 block mb-1">Jarak (m)</label>
              <input type="number" placeholder="Masukkan jarak‚Ä¶" step="0.001" class="w-full p-3 border border-gray-300 rounded-lg polygon-sub-distance" id="input-distance-value">
             </div>
            </div>
            <!-- Method 2: Distance Only -->
            <div id="method-distance-input" class="space-y-3 hidden">
             <select class="w-full p-3 border border-gray-300 rounded-lg polygon-sub-main-dist"><option value="">Pilih Titik Utama</option></select>
             <input type="text" placeholder="Nama (a1, b1...)" class="w-full p-3 border border-gray-300 rounded-lg polygon-sub-name-dist">
             <!-- Add label for distance-only input -->
             <div>
              <label class="text-sm font-semibold text-gray-700 block mb-1">Jarak (m)</label>
              <input type="number" placeholder="Masukkan jarak‚Ä¶" step="0.001" class="w-full p-3 border border-gray-300 rounded-lg polygon-sub-distance-only" id="input-distance-only-value">
             </div>
            </div>
            <!-- Method 3: Height Only -->
            <div id="method-height-input" class="space-y-3 hidden">
             <select class="w-full p-3 border border-gray-300 rounded-lg polygon-sub-main-height"><option value="">Pilih Titik Utama</option></select>
             <input type="text" placeholder="Nama (a1, b1...)" class="w-full p-3 border border-gray-300 rounded-lg polygon-sub-name-height">
             <!-- Add label for height-only input -->
             <div>
              <label class="text-sm font-semibold text-gray-700 block mb-1">Tinggi (m)</label>
              <input type="number" placeholder="Masukkan tinggi‚Ä¶" step="0.001" class="w-full p-3 border border-gray-300 rounded-lg polygon-sub-z-height" id="input-height-value">
             </div>
            </div><button onclick="addSubPoint()" class="w-full btn-gradient text-white px-4 py-2 rounded-lg font-semibold">Tambah Titik Turunan</button>
           </div>
           <div class="space-y-3"><button onclick="calculatePolygon()" class="w-full bg-blue-600 hover:bg-blue-700 text-white px-4 py-3 rounded-lg font-semibold">Hitung Poligon</button> <button onclick="loadSampleData('polygon')" class="w-full bg-gray-600 hover:bg-gray-700 text-white px-4 py-2 rounded-lg font-semibold">üìã Load Data Contoh</button> <button onclick="clearData('polygon')" class="w-full bg-red-600 hover:bg-red-700 text-white px-4 py-2 rounded-lg font-semibold">Clear Data</button> <button onclick="exportPolygonData('csv')" class="w-full bg-green-600 hover:bg-green-700 text-white px-4 py-2 rounded-lg font-semibold">Ekspor CSV</button> <button onclick="exportPolygonData('json')" class="w-full bg-purple-600 hover:bg-purple-700 text-white px-4 py-2 rounded-lg font-semibold">Ekspor JSON</button>
           </div>
          </div><!-- Results Section -->
          <div class="xl:col-span-2">
           <h3 class="text-xl font-bold mb-6">Hasil Perhitungan</h3><!-- Summary Stats -->
           <div class="grid grid-cols-2 md:grid-cols-4 gap-4 mb-6">
            <div class="bg-blue-50 border border-blue-200 rounded-lg p-4 text-center">
             <h5 class="font-semibold text-blue-800 mb-1">Perimeter</h5>
             <p id="polygon-perimeter" class="text-lg font-bold text-blue-600">0.00 m</p>
            </div>
            <div class="bg-green-50 border border-green-200 rounded-lg p-4 text-center">
             <h5 class="font-semibold text-green-800 mb-1">Luas</h5>
             <p id="polygon-area" class="text-lg font-bold text-green-600">0.00 m¬≤</p>
            </div>
            <div class="bg-purple-50 border border-purple-200 rounded-lg p-4 text-center">
             <h5 class="font-semibold text-purple-800 mb-1">Titik Utama</h5>
             <p id="polygon-main-count" class="text-lg font-bold text-purple-600">0</p>
            </div>
            <div class="bg-orange-50 border border-orange-200 rounded-lg p-4 text-center">
             <h5 class="font-semibold text-orange-800 mb-1">Titik Turunan</h5>
             <p id="polygon-sub-count" class="text-lg font-bold text-orange-600">0</p>
            </div>
           </div><!-- Tabel Titik Utama -->
           <div class="mb-6">
            <h4 class="font-semibold text-gray-700 mb-3">Tabel Titik Utama</h4>
            <div class="overflow-x-auto">
             <table class="w-full border-collapse border border-gray-300 rounded-lg text-sm">
              <thead class="bg-blue-50">
               <tr>
                <th class="border border-gray-300 px-3 py-2 text-left">Titik</th>
                <th class="border border-gray-300 px-3 py-2 text-right">X (m)</th>
                <th class="border border-gray-300 px-3 py-2 text-right">Y (m)</th>
                <th class="border border-gray-300 px-3 py-2 text-right">Z (m)</th>
                <th class="border border-gray-300 px-3 py-2 text-right">Azimuth (¬∞)</th>
                <th class="border border-gray-300 px-3 py-2 text-right">Jarak (m)</th>
                <th class="border border-gray-300 px-3 py-2 text-center">Aksi</th>
               </tr>
              </thead>
              <tbody id="polygon-main-table-body">
               <tr>
                <td colspan="7" class="border border-gray-300 px-4 py-8 text-center text-gray-500">Belum ada titik utama</td>
               </tr>
              </tbody>
             </table>
            </div>
           </div><!-- Tabel Titik Turunan -->
           <div class="mb-6">
            <h4 class="font-semibold text-gray-700 mb-3">Tabel Titik Turunan</h4>
            <div class="overflow-x-auto">
             <table class="w-full border-collapse border border-gray-300 rounded-lg text-sm">
              <thead class="bg-green-50">
               <tr>
                <th class="border border-gray-300 px-3 py-2 text-left">Titik</th>
                <th class="border border-gray-300 px-3 py-2 text-left">Utama</th>
                <th class="border border-gray-300 px-3 py-2 text-right">X (m)</th>
                <th class="border border-gray-300 px-3 py-2 text-right">Y (m)</th>
                <th class="border border-gray-300 px-3 py-2 text-right">Z (m)</th>
                <th class="border border-gray-300 px-3 py-2 text-center">Metode</th>
                <th class="border border-gray-300 px-3 py-2 text-center">Aksi</th>
               </tr>
              </thead>
              <tbody id="polygon-sub-table-body">
               <tr>
                <td colspan="7" class="border border-gray-300 px-4 py-8 text-center text-gray-500">Belum ada titik turunan</td>
               </tr>
              </tbody>
             </table>
            </div>
           </div><!-- Visualization -->
           <div class="mt-6">
            <!-- Added mode toggle buttons for 2D/3D visualization -->
            <div class="flex gap-2 mb-4">
                <button class="mode-toggle-btn active" onclick="switchVisualizationMode('2d')">üìä Mode 2D</button>
                <button class="mode-toggle-btn" onclick="switchVisualizationMode('3d')">üéØ Mode 3D</button>
            </div>

            <!-- 2D Visualization with Contours -->
            <div id="visualization-2d">
                <h4 class="font-semibold text-gray-700 mb-3">Preview Poligon & Kontur 2D</h4>
                <div id="polygon-preview" class="border border-gray-300 rounded-lg bg-gray-50 h-80 flex items-center justify-center relative">
                    <p class="text-gray-500">Tambahkan minimal 3 titik utama untuk melihat preview</p>
                </div>
                <!-- Added contour legend below visualization -->
                <div id="contour-legend" class="mt-3 contour-legend" style="display: none;">
                    <strong class="text-sm text-gray-700">Legenda Kontur:</strong>
                    <div id="legend-items"></div>
                </div>
            </div>

            <!-- 3D Visualization -->
            <div id="visualization-3d" style="display: none;">
                <h4 class="font-semibold text-gray-700 mb-3">Preview Topografi 3D</h4>
                <canvas id="canvas-3d"></canvas>
                <p class="text-xs text-gray-600 mt-2">Drag untuk merotasi ‚Ä¢ Scroll untuk zoom</p>
            </div>
           </div>
          </div>
         </div>
        </div><!-- Grid Module -->
        <div id="grid-calc" class="surveyor-content hidden">
         <div class="grid grid-cols-1 xl:grid-cols-3 gap-8"><!-- Input Section -->
          <div class="xl:col-span-1">
           <h3 class="text-xl font-bold mb-6">Input Data Grid</h3>
           <div class="space-y-4 mb-6">
            <div class="grid grid-cols-4 gap-2"><input type="text" placeholder="Nama" class="p-3 border border-gray-300 rounded-lg grid-name"> <input type="number" placeholder="X (m)" step="0.001" class="p-3 border border-gray-300 rounded-lg grid-x"> <input type="number" placeholder="Y (m)" step="0.001" class="p-3 border border-gray-300 rounded-lg grid-y"> <input type="number" placeholder="Z (m)" step="0.001" class="p-3 border border-gray-300 rounded-lg grid-z">
            </div><button onclick="addGridPoint()" class="w-full btn-gradient text-white px-4 py-2 rounded-lg font-semibold">Tambah Titik Grid</button>
           </div>
           <div class="space-y-3"><button onclick="calculateGrid()" class="w-full bg-blue-600 hover:bg-blue-700 text-white px-4 py-3 rounded-lg font-semibold">Hitung Grid</button> <button onclick="loadSampleData('grid')" class="w-full bg-gray-600 hover:bg-gray-700 text-white px-4 py-2 rounded-lg font-semibold">üìã Load Data Contoh</button> <button onclick="clearData('grid')" class="w-full bg-red-600 hover:bg-red-700 text-white px-4 py-2 rounded-lg font-semibold">Clear Data</button> <button onclick="exportData('grid', 'csv')" class="w-full bg-green-600 hover:bg-green-700 text-white px-4 py-2 rounded-lg font-semibold">Ekspor CSV</button>
           </div>
          </div><!-- Results Section -->
          <div class="xl:col-span-2">
           <h3 class="text-xl font-bold mb-6">Hasil Perhitungan Grid</h3>
           <div class="grid grid-cols-2 md:grid-cols-3 gap-4 mb-6">
            <div class="bg-blue-50 border border-blue-200 rounded-lg p-4 text-center">
             <h5 class="font-semibold text-blue-800 mb-1">Total Titik</h5>
             <p id="grid-count" class="text-lg font-bold text-blue-600">0</p>
            </div>
            <div class="bg-green-50 border border-green-200 rounded-lg p-4 text-center">
             <h5 class="font-semibold text-green-800 mb-1">Elevasi Rata-rata</h5>
             <p id="grid-avg-elevation" class="text-lg font-bold text-green-600">0.00 m</p>
            </div>
            <div class="bg-purple-50 border border-purple-200 rounded-lg p-4 text-center">
             <h5 class="font-semibold text-purple-800 mb-1">Range Elevasi</h5>
             <p id="grid-elevation-range" class="text-lg font-bold text-purple-600">0.00 m</p>
            </div>
           </div>
           <div class="overflow-x-auto">
            <table class="w-full border-collapse border border-gray-300 rounded-lg">
             <thead class="bg-blue-50">
              <tr>
               <th class="border border-gray-300 px-4 py-2 text-left">Nama</th>
               <th class="border border-gray-300 px-4 py-2 text-right">X (m)</th>
               <th class="border border-gray-300 px-4 py-2 text-right">Y (m)</th>
               <th class="border border-gray-300 px-4 py-2 text-right">Z (m)</th>
               <th class="border border-gray-300 px-4 py-2 text-center">Aksi</th>
              </tr>
             </thead>
             <tbody id="grid-table-body">
              <tr>
               <td colspan="5" class="border border-gray-300 px-4 py-8 text-center text-gray-500">Belum ada data grid</td>
              </tr>
             </tbody>
            </table>
           </div>
           <div class="mt-6">
            <h4 class="font-semibold text-gray-700 mb-3">Preview Grid</h4>
            <div id="grid-preview" class="border border-gray-300 rounded-lg bg-gray-50 h-64 flex items-center justify-center">
             <p class="text-gray-500">Tambahkan titik grid untuk melihat preview</p>
            </div>
           </div>
          </div>
         </div>
        </div><!-- Profile/Transek Module -->
        <div id="profile-calc" class="surveyor-content hidden">
         <div class="grid grid-cols-1 xl:grid-cols-3 gap-8"><!-- Input Section -->
          <div class="xl:col-span-1">
           <h3 class="text-xl font-bold mb-6">Input Data Profil/Transek</h3>
           <div class="space-y-4 mb-6">
            <div class="grid grid-cols-3 gap-2"><input type="text" placeholder="Nama" class="p-3 border border-gray-300 rounded-lg profile-name"> <input type="number" placeholder="Jarak (m)" step="0.001" class="p-3 border border-gray-300 rounded-lg profile-distance"> <input type="number" placeholder="Elevasi (m)" step="0.001" class="p-3 border border-gray-300 rounded-lg profile-elevation">
            </div><button onclick="addProfilePoint()" class="w-full btn-gradient text-white px-4 py-2 rounded-lg font-semibold">Tambah Titik Profil</button>
           </div>
           <div class="space-y-3"><button onclick="calculateProfile()" class="w-full bg-blue-600 hover:bg-blue-700 text-white px-4 py-3 rounded-lg font-semibold">Hitung Profil</button> <button onclick="loadSampleData('profile')" class="w-full bg-gray-600 hover:bg-gray-700 text-white px-4 py-2 rounded-lg font-semibold">üìã Load Data Contoh</button> <button onclick="clearData('profile')" class="w-full bg-red-600 hover:bg-red-700 text-white px-4 py-2 rounded-lg font-semibold">Clear Data</button> <button onclick="exportData('profile', 'csv')" class="w-full bg-green-600 hover:bg-green-700 text-white px-4 py-2 rounded-lg font-semibold">Ekspor CSV</button>
           </div>
          </div><!-- Results Section -->
          <div class="xl:col-span-2">
           <h3 class="text-xl font-bold mb-6">Hasil Perhitungan Profil</h3>
           <div class="grid grid-cols-2 md:grid-cols-4 gap-4 mb-6">
            <div class="bg-blue-50 border border-blue-200 rounded-lg p-4 text-center">
             <h5 class="font-semibold text-blue-800 mb-1">Total Jarak</h5>
             <p id="profile-total-distance" class="text-lg font-bold text-blue-600">0.00 m</p>
            </div>
            <div class="bg-green-50 border border-green-200 rounded-lg p-4 text-center">
             <h5 class="font-semibold text-green-800 mb-1">Kemiringan Rata-rata</h5>
             <p id="profile-avg-slope" class="text-lg font-bold text-green-600">0.00%</p>
            </div>
            <div class="bg-purple-50 border border-purple-200 rounded-lg p-4 text-center">
             <h5 class="font-semibold text-purple-800 mb-1">Elevasi Tertinggi</h5>
             <p id="profile-max-elevation" class="text-lg font-bold text-purple-600">0.00 m</p>
            </div>
            <div class="bg-orange-50 border border-orange-200 rounded-lg p-4 text-center">
             <h5 class="font-semibold text-orange-800 mb-1">Elevasi Terendah</h5>
             <p id="profile-min-elevation" class="text-lg font-bold text-orange-600">0.00 m</p>
            </div>
           </div>
           <div class="overflow-x-auto">
            <table class="w-full border-collapse border border-gray-300 rounded-lg">
             <thead class="bg-blue-50">
              <tr>
               <th class="border border-gray-300 px-4 py-2 text-left">Nama</th>
               <th class="border border-gray-300 px-4 py-2 text-right">Jarak (m)</th>
               <th class="border border-gray-300 px-4 py-2 text-right">Elevasi (m)</th>
               <th class="border border-gray-300 px-4 py-2 text-right">Kemiringan (%)</th>
               <th class="border border-gray-300 px-4 py-2 text-center">Aksi</th>
              </tr>
             </thead>
             <tbody id="profile-table-body">
              <tr>
               <td colspan="5" class="border border-gray-300 px-4 py-8 text-center text-gray-500">Belum ada data profil</td>
              </tr>
             </tbody>
            </table>
           </div>
           <div class="mt-6">
            <h4 class="font-semibold text-gray-700 mb-3">Grafik Profil</h4>
            <div id="profile-chart" class="border border-gray-300 rounded-lg bg-gray-50 h-64 flex items-center justify-center">
             <p class="text-gray-500">Tambahkan titik profil untuk melihat grafik</p>
            </div>
           </div>
          </div>
         </div>
        </div><!-- Random Points Module -->
        <div id="random-calc" class="surveyor-content hidden">
         <div class="grid grid-cols-1 xl:grid-cols-3 gap-8"><!-- Input Section -->
          <div class="xl:col-span-1">
           <h3 class="text-xl font-bold mb-6">Input Titik Acak</h3>
           <div class="space-y-4 mb-6">
            <div class="grid grid-cols-4 gap-2"><input type="text" placeholder="Nama" class="p-3 border border-gray-300 rounded-lg random-name"> <input type="number" placeholder="X (m)" step="0.001" class="p-3 border border-gray-300 rounded-lg random-x"> <input type="number" placeholder="Y (m)" step="0.001" class="p-3 border border-gray-300 rounded-lg random-y"> <input type="number" placeholder="Z (m)" step="0.001" class="p-3 border border-gray-300 rounded-lg random-z">
            </div><button onclick="addRandomPoint()" class="w-full btn-gradient text-white px-4 py-2 rounded-lg font-semibold">Tambah Titik Acak</button>
           </div>
           <div class="space-y-3"><button onclick="calculateRandom()" class="w-full bg-blue-600 hover:bg-blue-700 text-white px-4 py-3 rounded-lg font-semibold">Analisis Titik Acak</button> <button onclick="loadSampleData('random')" class="w-full bg-gray-600 hover:bg-gray-700 text-white px-4 py-2 rounded-lg font-semibold">üìã Load Data Contoh</button> <button onclick="clearData('random')" class="w-full bg-red-600 hover:bg-red-700 text-white px-4 py-2 rounded-lg font-semibold">Clear Data</button> <button onclick="exportData('random', 'csv')" class="w-full bg-green-600 hover:bg-green-700 text-white px-4 py-2 rounded-lg font-semibold">Ekspor CSV</button>
           </div>
          </div><!-- Results Section -->
          <div class="xl:col-span-2">
           <h3 class="text-xl font-bold mb-6">Hasil Analisis Titik Acak</h3>
           <div class="grid grid-cols-2 md:grid-cols-3 gap-4 mb-6">
            <div class="bg-blue-50 border border-blue-200 rounded-lg p-4 text-center">
             <h5 class="font-semibold text-blue-800 mb-1">Total Titik</h5>
             <p id="random-count" class="text-lg font-bold text-blue-600">0</p>
            </div>
            <div class="bg-green-50 border border-green-200 rounded-lg p-4 text-center">
             <h5 class="font-semibold text-green-800 mb-1">Jarak Rata-rata</h5>
             <p id="random-avg-distance" class="text-lg font-bold text-green-600">0.00 m</p>
            </div>
            <div class="bg-purple-50 border border-purple-200 rounded-lg p-4 text-center">
             <h5 class="font-semibold text-purple-800 mb-1">Sebaran Area</h5>
             <p id="random-area" class="text-lg font-bold text-purple-600">0.00 m¬≤</p>
            </div>
           </div>
           <div class="overflow-x-auto">
            <table class="w-full border-collapse border border-gray-300 rounded-lg">
             <thead class="bg-blue-50">
              <tr>
               <th class="border border-gray-300 px-4 py-2 text-left">Nama</th>
               <th class="border border-gray-300 px-4 py-2 text-right">X (m)</th>
               <th class="border border-gray-300 px-4 py-2 text-right">Y (m)</th>
               <th class="border border-gray-300 px-4 py-2 text-right">Z (m)</th>
               <th class="border border-gray-300 px-4 py-2 text-right">Jarak ke Pusat (m)</th>
               <th class="border border-gray-300 px-4 py-2 text-center">Aksi</th>
              </tr>
             </thead>
             <tbody id="random-table-body">
              <tr>
               <td colspan="6" class="border border-gray-300 px-4 py-8 text-center text-gray-500">Belum ada titik acak</td>
              </tr>
             </tbody>
            </table>
           </div>
           <div class="mt-6">
            <h4 class="font-semibold text-gray-700 mb-3">Sebaran Titik Acak</h4>
            <div id="random-preview" class="border border-gray-300 rounded-lg bg-gray-50 h-64 flex items-center justify-center">
             <p class="text-gray-500">Tambahkan titik acak untuk melihat sebaran</p>
            </div>
           </div>
          </div>
         </div>
        </div>
       </div>
      </div>
     </section>
    </div><!-- Partner Page -->
    <div id="partner-page" class="page-content hidden">
     <section class="min-h-screen p-8">
      <div class="max-w-6xl mx-auto">
       <h2 class="text-4xl font-bold mb-12 text-center">Mitra Bisnis Kami</h2>
       <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-8 mb-12">
        <div class="glass rounded-2xl p-8 text-center fade-in">
         <div class="w-20 h-20 mx-auto mb-6 rounded-full bg-gradient-to-r from-blue-500 to-cyan-500 flex items-center justify-center">
          <span class="text-3xl font-bold text-white">PT</span>
         </div>
         <h3 class="text-xl font-bold mb-2">PT Konstruksi Besar</h3>
         <p class="text-gray-600 text-sm mb-4">Mitra utama dalam proyek infrastruktur skala besar dan pembangunan perkotaan.</p>
         <p class="text-blue-600 font-semibold">50+ Proyek</p>
        </div>
        <div class="glass rounded-2xl p-8 text-center fade-in" style="animation-delay: 0.2s;">
         <div class="w-20 h-20 mx-auto mb-6 rounded-full bg-gradient-to-r from-blue-500 to-cyan-500 flex items-center justify-center">
          <span class="text-3xl font-bold text-white">DA</span>
         </div>
         <h3 class="text-xl font-bold mb-2">Dinas Aset & Infrastruktur</h3>
         <p class="text-gray-600 text-sm mb-4">Kerjasama untuk survey dan pemetaan aset publik serta infrastruktur pemerintah.</p>
         <p class="text-blue-600 font-semibold">25+ Proyek</p>
        </div>
        <div class="glass rounded-2xl p-8 text-center fade-in" style="animation-delay: 0.4s;">
         <div class="w-20 h-20 mx-auto mb-6 rounded-full bg-gradient-to-r from-blue-500 to-cyan-500 flex items-center justify-center">
          <span class="text-3xl font-bold text-white">PG</span>
         </div>
         <h3 class="text-xl font-bold mb-2">Pertanian & Geospasial</h3>
         <p class="text-gray-600 text-sm mb-4">Mitra dalam penelitian lahan pertanian dan analisis geospasial pertanian berkelanjutan.</p>
         <p class="text-blue-600 font-semibold">15+ Proyek</p>
        </div>
       </div>
       <div class="glass rounded-2xl p-12">
        <h3 class="text-2xl font-bold mb-6">Bergabunglah dengan Network Kami</h3>
        <p class="text-gray-600 mb-6">Kami membuka peluang kemitraan untuk perusahaan dan profesional yang ingin bergabung dalam ekosistem survey dan pemetaan profesional.</p>
        <button onclick="navigateToPage('contact')" class="btn-gradient text-white px-8 py-3 rounded-lg font-semibold">Hubungi Kami Sekarang</button>
       </div>
      </div>
     </section>
    </div><!-- Contact Page -->
    <div id="contact-page" class="page-content hidden">
     <section class="min-h-screen p-8">
      <div class="max-w-6xl mx-auto">
       <h2 class="text-4xl font-bold mb-12 text-center">Hubungi Kami</h2>
       <div class="grid grid-cols-1 lg:grid-cols-2 gap-12">
        <div class="fade-in">
         <h3 class="text-2xl font-bold mb-8">Informasi Kontak</h3>
         <div class="space-y-6">
          <div class="flex items-start">
           <div class="w-12 h-12 rounded-full bg-gradient-to-r from-blue-500 to-cyan-500 flex items-center justify-center flex-shrink-0">
            <svg class="w-6 h-6 text-white" fill="none" stroke="currentColor" viewbox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17.657 16.657L13.414 20.9a1.998 1.998 0 01-2.827 0l-4.244-4.243a8 8 0 1111.314 0z" /> <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 11a3 3 0 11-6 0 3 3 0 016 0z" />
            </svg>
           </div>
           <div class="ml-4">
            <h4 class="text-lg font-bold text-gray-900">Alamat</h4>
            <p class="text-gray-600">Jl. Teknologi No. 123, Jakarta Selatan 12345</p>
           </div>
          </div>
          <div class="flex items-start">
           <div class="w-12 h-12 rounded-full bg-gradient-to-r from-blue-500 to-cyan-500 flex items-center justify-center flex-shrink-0">
            <svg class="w-6 h-6 text-white" fill="none" stroke="currentColor" viewbox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 5a2 2 0 012-2h3.28a1 1 0 01.948.684l1.498 4.493a1 1 0 01-.502 1.21l-2.257 1.13a11.042 11.042 0 005.516 5.516l1.13-2.257a1 1 0 011.21-.502l4.493 1.498a1 1 0 01.684.949V19a2 2 0 01-2 2h-1C9.716 21 3 14.284 3 6V5z" />
            </svg>
           </div>
           <div class="ml-4">
            <h4 class="text-lg font-bold text-gray-900">Telepon</h4>
            <p class="text-gray-600">+62 21 5555 1234</p>
           </div>
          </div>
          <div class="flex items-start">
           <div class="w-12 h-12 rounded-full bg-gradient-to-r from-blue-500 to-cyan-500 flex items-center justify-center flex-shrink-0">
            <svg class="w-6 h-6 text-white" fill="none" stroke="currentColor" viewbox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 8l7.89 5.26a2 2 0 002.22 0L21 8M5 19h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v10a2 2 0 002 2z" />
            </svg>
           </div>
           <div class="ml-4">
            <h4 class="text-lg font-bold text-gray-900">Email</h4>
            <p class="text-gray-600">info@minametrics.com</p>
           </div>
          </div>
          <div class="flex items-start">
           <div class="w-12 h-12 rounded-full bg-gradient-to-r from-blue-500 to-cyan-500 flex items-center justify-center flex-shrink-0">
            <svg class="w-6 h-6 text-white" fill="none" stroke="currentColor" viewbox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z" />
            </svg>
           </div>
           <div class="ml-4">
            <h4 class="text-lg font-bold text-gray-900">Jam Operasional</h4>
            <p class="text-gray-600">Senin - Jumat: 09:00 - 17:00</p>
           </div>
          </div>
         </div>
        </div>
        <div class="glass rounded-2xl p-8 fade-in" style="animation-delay: 0.2s;">
         <h3 class="text-2xl font-bold mb-6">Formulir Kontak</h3>
         <form class="space-y-4">
          <input type="text" placeholder="Nama Anda" class="w-full p-3 border border-gray-300 rounded-lg focus:outline-none focus:border-blue-500">
          <input type="email" placeholder="Email Anda" class="w-full p-3 border border-gray-300 rounded-lg focus:outline-none focus:border-blue-500">
          <input type="text" placeholder="Subjek" class="w-full p-3 border border-gray-300 rounded-lg focus:outline-none focus:border-blue-500">
          <textarea placeholder="Pesan Anda" rows="5" class="w-full p-3 border border-gray-300 rounded-lg focus:outline-none focus:border-blue-500"></textarea>
          <button type="submit" class="w-full btn-gradient text-white px-6 py-3 rounded-lg font-semibold">Kirim Pesan</button>
         </form>
        </div>
       </div>
      </div>
     </section>
    </div>
   </div>
  </div>
  <script>
        const defaultConfig = {
            brand_name: "MinaMetrics",
            hero_tagline: "Teknologi Survey Terdepan",
            hero_title: "Solusi Survey Profesional untuk Masa Depan",
            hero_description: "Dengan teknologi terdepan dan tim berpengalaman, kami memberikan layanan survey topografi, pemetaan GPS, dan analisis kontur yang akurat untuk proyek konstruksi dan infrastruktur Anda.",
            ceo_name: "Tika Nur Aminah, S.T.",
            ceo_title: "CEO & Founder"
        };

        // Element SDK integration
        function onConfigChange(config) {
            const brandElement = document.getElementById('brand-name');
            if (brandElement) {
                brandElement.textContent = config.brand_name || defaultConfig.brand_name;
            }

            const taglineElement = document.getElementById('hero-tagline');
            if (taglineElement) {
                taglineElement.textContent = config.hero_tagline || defaultConfig.hero_tagline;
            }

            const titleElement = document.getElementById('hero-title');
            if (titleElement) {
                titleElement.textContent = config.hero_title || defaultConfig.hero_title;
            }

            const descElement = document.getElementById('hero-description');
            if (descElement) {
                descElement.textContent = config.hero_description || defaultConfig.hero_description;
            }

            const ceoNameElement = document.getElementById('ceo-name');
            if (ceoNameElement) {
                ceoNameElement.textContent = config.ceo_name || defaultConfig.ceo_name;
            }

            const ceoTitleElement = document.getElementById('ceo-title');
            if (ceoTitleElement) {
                ceoTitleElement.textContent = config.ceo_title || defaultConfig.ceo_title;
            }
        }

        function mapToCapabilities(config) {
            return {
                recolorables: [],
                borderables: [],
                fontEditable: undefined,
                fontSizeable: undefined
            };
        }

        function mapToEditPanelValues(config) {
            return new Map([
                ["brand_name", config.brand_name || defaultConfig.brand_name],
                ["hero_tagline", config.hero_tagline || defaultConfig.hero_tagline],
                ["hero_title", config.hero_title || defaultConfig.hero_title],
                ["hero_description", config.hero_description || defaultConfig.hero_description],
                ["ceo_name", config.ceo_name || defaultConfig.ceo_name],
                ["ceo_title", config.ceo_title || defaultConfig.ceo_title]
            ]);
        }

        if (window.elementSdk) {
            window.elementSdk.init({
                defaultConfig,
                onConfigChange,
                mapToCapabilities,
                mapToEditPanelValues
            });
        }

        // Navigation function
        function navigateToPage(pageName) {
          document.querySelectorAll('.page-content').forEach(page => {
            page.classList.add('hidden');
          });
          
          const targetPage = document.getElementById(pageName + '-page');
          if (targetPage) {
            targetPage.classList.remove('hidden');
          }

          const mobileMenu = document.getElementById('mobile-menu');
          if (mobileMenu) {
            mobileMenu.classList.remove('active');
          }

          window.scrollTo({ top: 0, behavior: 'smooth' });
        }

        // Mobile menu toggle
        document.getElementById('mobile-menu-btn').addEventListener('click', function() {
          const mobileMenu = document.getElementById('mobile-menu');
          mobileMenu.classList.toggle('active');
        });

        // Theme toggle
        let currentTheme = 'light'; // Default theme

        function toggleTheme() {
            const html = document.documentElement;
            const body = document.body;
            
            if (currentTheme === 'light') {
                currentTheme = 'dark';
                html.classList.add('dark-mode');
                body.classList.add('dark-mode');
                localStorage.setItem('theme', 'dark');
            } else {
                currentTheme = 'light';
                html.classList.remove('dark-mode');
                body.classList.remove('dark-mode');
                localStorage.setItem('theme', 'light');
            }
            updateThemeIcon();
            
            // Redraw visualization with new theme colors if active
            if (currentVisualizationMode === '2d' && polygonMainPoints.length >= 3) {
                drawPolygonPreviewWithEnhancedVisualization();
            } else if (currentVisualizationMode === '3d' && polygonMainPoints.length >= 3) {
                initialize3DVisualization();
            }
        }

        function updateThemeIcon() {
            const isDark = document.documentElement.classList.contains('dark-mode');
            const icon = isDark ? 'üåô' : '‚òÄÔ∏è';
            document.getElementById('theme-icon').textContent = icon;
            const desktopIcon = document.getElementById('theme-icon-desktop');
            if (desktopIcon) desktopIcon.textContent = icon;
        }

        // Theme toggle buttons event listeners
        document.getElementById('theme-toggle-btn').addEventListener('click', toggleTheme);
        const desktopToggle = document.querySelector('.desktop-theme-toggle');
        if (desktopToggle) {
            desktopToggle.addEventListener('click', toggleTheme);
        }

        // Initialize theme and default page on load
        window.addEventListener('DOMContentLoaded', function() {
            const savedTheme = localStorage.getItem('theme') || 'light';
            currentTheme = savedTheme; // Set currentTheme based on saved value
            applyTheme(savedTheme); // Apply initial theme
            navigateToPage('home');
            
            // Initial check for 3D visualization mode if it's already set to active
            if (currentVisualizationMode === '3d') {
                initialize3DVisualization();
            }
        });

        function applyTheme(theme) {
            const html = document.documentElement;
            const body = document.body;
            
            if (theme === 'dark') {
                html.classList.add('dark-mode');
                body.classList.add('dark-mode');
            } else {
                html.classList.remove('dark-mode');
                body.classList.remove('dark-mode');
            }
            updateThemeIcon();
        }


        let polygonMainPoints = [];
        let polygonSubPoints = [];
        let currentSubMethod = 'angle';

        let gridPoints = [];
        let profilePoints = [];
        let randomPoints = [];

        let contourLevels = [];
        let visualization3DScene = null;
        let visualization3DRenderer = null;
        let visualization3DCamera = null;
        let visualization3DControls = null;
        let currentVisualizationMode = '2d'; // Default mode

        function switchVisualizationMode(mode) {
            currentVisualizationMode = mode;
            document.querySelectorAll('.mode-toggle-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');

            document.getElementById('visualization-2d').style.display = mode === '2d' ? 'block' : 'none';
            document.getElementById('visualization-3d').style.display = mode === '3d' ? 'block' : 'none';

            if (mode === '3d') {
                // Delay initialization to ensure canvas is rendered and has dimensions
                setTimeout(initialize3DVisualization, 100); 
            } else {
                // Redraw 2D visualization if points exist
                if (polygonMainPoints.length >= 3) {
                    drawPolygonPreviewWithEnhancedVisualization();
                } else {
                    document.getElementById('polygon-preview').innerHTML = '<p class="text-gray-500">Tambahkan minimal 3 titik utama untuk melihat preview</p>';
                    document.getElementById('contour-legend').style.display = 'none';
                }
            }
        }

        // Enhanced contour line generation function
        function generateContourLines(points) {
            if (!points || points.length < 3) return { levels: [], colors: [] };

            const zValues = points.map(p => p.z).filter(z => !isNaN(z));
            if (zValues.length === 0) return { levels: [], colors: [] };

            const minZ = Math.min(...zValues);
            const maxZ = Math.max(...zValues);
            const range = maxZ - minZ;

            if (range === 0) {
                return { levels: [minZ], colors: ['#0ea5e9'] }; // Single level if all Z are the same
            }

            // Generate contour levels (e.g., 5 levels as in reference)
            const interval = range / 5;
            const levels = [];
            for (let i = 0; i <= 5; i++) {
                levels.push(minZ + i * interval);
            }

            // Define a color palette for contour lines
            const colors = [
                '#1f2937', // dark gray
                '#374151', // gray
                '#6b7280', // medium gray
                '#9ca3af', // light gray
                '#d1d5db', // lighter gray
                '#e5e7eb'  // lightest gray
            ];

            return { levels, colors };
        }

        // Enhanced drawPolygonPreviewWithEnhancedVisualization for smooth contour lines and better labeling
        function drawPolygonPreviewWithEnhancedVisualization() {
            const preview = document.getElementById('polygon-preview');
            if (polygonMainPoints.length < 3) {
                preview.innerHTML = '<p class="text-gray-500">Tambahkan minimal 3 titik utama untuk melihat preview</p>';
                document.getElementById('contour-legend').style.display = 'none';
                return;
            }

            // Combine main and sub points for visualization
            const orderedPoints = [];
            polygonMainPoints.forEach((mainPt) => {
                orderedPoints.push({
                    ...mainPt,
                    isSubPoint: false,
                    method: null,
                    mainPoint: null // Main points don't have a 'mainPoint' parent
                });
                
                const subPtsForMain = polygonSubPoints.filter(sp => sp.mainPoint === mainPt.name);
                subPtsForMain.forEach((subPt) => {
                    orderedPoints.push({
                        ...subPt,
                        isSubPoint: true,
                        origPoint: mainPt // Keep reference to the main point
                    });
                });
            });

            // Determine bounds for scaling
            const xValues = orderedPoints.map(p => p.x);
            const yValues = orderedPoints.map(p => p.y);
            const minX = Math.min(...xValues);
            const maxX = Math.max(...xValues);
            const minY = Math.min(...yValues);
            const maxY = Math.max(...yValues);
            
            const width = 500; // SVG canvas width
            const height = 320; // SVG canvas height
            const padding = 50; // Padding around the drawing
            
            const rangeX = maxX - minX || 1;
            const rangeY = maxY - minY || 1;
            const scaleX = (width - 2 * padding) / rangeX;
            const scaleY = (height - 2 * padding) / rangeY;
            const scale = Math.min(scaleX, scaleY);

            // Scale points to SVG coordinates
            const svgPoints = orderedPoints.map(p => ({
                name: p.name,
                x: padding + (p.x - minX) * scale,
                y: height - padding - (p.y - minY) * scale, // Invert Y for SVG
                z: p.z,
                isSubPoint: p.isSubPoint,
                method: p.method,
                mainPoint: p.mainPoint,
                origPoint: p.origPoint,
                labelOffsetX: 0, // Initialize label offset
                labelOffsetY: 0
            }));

            // Apply label collision avoidance iteratively
            const maxIterations = 10; // Number of passes for collision detection
            for (let i = 0; i < maxIterations; i++) {
                svgPoints.forEach(pt => {
                    // Calculate label position offset to avoid overlaps
                    const offset = calculateLabelOffset(pt, svgPoints, svgPoints, { width, height }, pt.isSubPoint);
                    pt.labelOffsetX = offset.offsetX;
                    pt.labelOffsetY = offset.offsetY;
                });
            }

            // Create path for the polygon outline using Catmull-Rom splines for smoothness
            let pathData = `M ${svgPoints[0].x} ${svgPoints[0].y}`;
            
            // Using C (Cubic Bezier) for a simpler smooth curve, Catmull-Rom is more complex for SVG directly
            for (let i = 0; i < svgPoints.length; i++) {
                const current = svgPoints[i];
                const next = svgPoints[(i + 1) % svgPoints.length];
                const prev = svgPoints[i > 0 ? i - 1 : svgPoints.length - 1]; // Previous point
                const nextNext = svgPoints[(i + 2) % svgPoints.length]; // Point after next
                
                // Calculate control points for Bezier curve
                // This formula aims to create a smooth curve based on surrounding points
                const cp1x = current.x + (next.x - prev.x) / 6;
                const cp1y = current.y + (next.y - prev.y) / 6;
                const cp2x = next.x - (nextNext.x - current.x) / 6;
                const cp2y = next.y - (nextNext.y - current.y) / 6;
                
                pathData += ` C ${cp1x} ${cp1y}, ${cp2x} ${cp2y}, ${next.x} ${next.y}`;
            }

            // Generate contour lines
            const { levels: contourLevels, colors: contourColors } = generateContourLines(orderedPoints);

            let svg = `<svg width="100%" height="100%" viewBox="0 0 ${width} ${height}" class="border rounded" style="background: var(--bg-primary);">
                <defs>
                    <marker id="arrowhead" markerWidth="10" markerHeight="10" refX="5" refY="5" orient="auto">
                        <polygon points="0 0, 10 5, 0 10" fill="#10b981"/>
                    </marker>
                </defs>
            `;

            // Draw contour lines
            if (contourLevels.length > 0 && svgPoints.length > 0) {
                const zValues = orderedPoints.map(p => p.z);
                const minZ = Math.min(...zValues);
                const maxZ = Math.max(...zValues);
                const zRange = maxZ - minZ || 1;

                contourLevels.forEach((level, idx) => {
                    const levelRatio = (level - minZ) / zRange; // Ratio between 0 and 1
                    const color = contourColors[idx % contourColors.length]; // Get color from palette
                    
                    // Find points where contour line intersects polygon edges
                    const contourPoints = [];
                    for (let i = 0; i < svgPoints.length; i++) {
                        const pt1 = svgPoints[i];
                        const pt2 = svgPoints[(i + 1) % svgPoints.length];
                        
                        // Check if the contour level lies between the Z values of two consecutive points
                        const zRatio1 = (pt1.z - minZ) / zRange;
                        const zRatio2 = (pt2.z - minZ) / zRange;
                        
                        if ((zRatio1 <= levelRatio && zRatio2 >= levelRatio) || (zRatio1 >= levelRatio && zRatio2 <= levelRatio)) {
                            // Linear interpolation to find the intersection point
                            // Avoid division by zero if zRatio1 and zRatio2 are very close
                            const t = Math.abs(zRatio1 - levelRatio) / Math.abs(zRatio2 - zRatio1 + 0.0001); 
                            const interpX = pt1.x + (pt2.x - pt1.x) * t;
                            const interpY = pt1.y + (pt2.y - pt1.y) * t;
                            contourPoints.push({ x: interpX, y: interpY });
                        }
                    }

                    // Draw the contour line if we found intersections
                    if (contourPoints.length >= 2) {
                        let pathStr = `M ${contourPoints[0].x} ${contourPoints[0].y}`;
                        for (let i = 1; i < contourPoints.length; i++) {
                            pathStr += ` L ${contourPoints[i].x} ${contourPoints[i].y}`;
                        }
                        // Close the path for contour area filling (optional)
                        if (contourPoints.length >= 3) {
                            pathStr += ` L ${contourPoints[0].x} ${contourPoints[0].y}`;
                        }

                        svg += `<path d="${pathStr}" fill="none" stroke="${color}" stroke-width="2" opacity="0.7" stroke-linecap="round" stroke-linejoin="round"/>`;
                        
                        // Add Z label near the contour line
                        if (contourPoints.length >= 2) {
                            const midIdx = Math.floor(contourPoints.length / 2);
                            const labelX = contourPoints[midIdx].x;
                            const labelY = contourPoints[midIdx].y;
                            svg += `<text x="${labelX}" y="${labelY - 8}" font-size="12" font-weight="bold" fill="${color}" text-anchor="middle" style="pointer-events: none;">+ ${level.toFixed(0)}</text>`;
                        }
                    }
                });
            }

            // Fill the main polygon area
            svg += `<path d="${pathData}" fill="rgba(59, 130, 246, 0.08)" stroke="none"/>`;
            
            // Draw dashed lines connecting main points to sub-points
            const dashedLineColor = getComputedStyle(document.documentElement).getPropertyValue('--dashed-line-color').trim();
            polygonMainPoints.forEach((mainPt) => {
                const svgMainPt = svgPoints.find(p => p.name === mainPt.name && !p.isSubPoint);
                if (svgMainPt) {
                    const subPtsForMain = polygonSubPoints.filter(sp => sp.mainPoint === mainPt.name);
                    subPtsForMain.forEach((subPt) => {
                        const svgSubPt = svgPoints.find(p => p.name === subPt.name && p.isSubPoint);
                        if (svgSubPt) {
                            const midX = (svgMainPt.x + svgSubPt.x) / 2;
                            const midY = (svgMainPt.y + svgSubPt.y) / 2;
                            
                            const dx = svgSubPt.x - svgMainPt.x;
                            const dy = svgSubPt.y - svgMainPt.y;
                            const dist = Math.sqrt(dx * dx + dy * dy);
                            // Calculate perpendicular offset for curve
                            const perpX = dist > 0 ? -dy / dist * (dist * 0.12) : 0; 
                            const perpY = dist > 0 ? dx / dist * (dist * 0.12) : 0;
                            
                            svg += `<path d="M ${svgMainPt.x} ${svgMainPt.y} Q ${midX + perpX} ${midY + perpY} ${svgSubPt.x} ${svgSubPt.y}" 
                                    fill="none" stroke="${dashedLineColor}" stroke-width="1.5" stroke-dasharray="5,3" opacity="0.7"/>`;
                        }
                    });
                }
            });
            
            // Draw the main polygon outline
            const accentColor = getComputedStyle(document.documentElement).getPropertyValue('--accent-secondary').trim();
            svg += `<path d="${pathData}" fill="none" stroke="${accentColor}" stroke-width="2.5" stroke-linejoin="round" stroke-linecap="round" opacity="0.95"/>`;
            
            // Draw points and labels
            svgPoints.forEach((p) => {
                if (!p.isSubPoint) {
                    // Main point style
                    svg += `<circle cx="${p.x}" cy="${p.y}" r="7" fill="#ef4444" stroke="#ffffff" stroke-width="2"/>`;
                    
                    const labelX = p.x + p.labelOffsetX;
                    const labelY = p.y + p.labelOffsetY;
                    const labelWidth = 65; // Width for main point label box
                    const labelHeight = 40; // Height for main point label box
                    
                    // Background box for main point label
                    svg += `<rect x="${labelX - labelWidth/2}" y="${labelY - labelHeight/2}" width="${labelWidth}" height="${labelHeight}" fill="rgba(255,255,255,0.96)" stroke="#3b82f6" stroke-width="1.5" rx="4"/>`;
                    svg += `<text x="${labelX}" y="${labelY - 14}" font-size="13" font-weight="bold" fill="#1f2937" text-anchor="middle">${p.name}</text>`;
                    svg += `<text x="${labelX}" y="${labelY - 2}" font-size="7.5" fill="#6b7280" text-anchor="middle">X:${p.x.toFixed(1)}</text>`;
                    svg += `<text x="${labelX}" y="${labelY + 8}" font-size="7.5" fill="#6b7280" text-anchor="middle">Y:${p.y.toFixed(1)}</text>`;
                    svg += `<text x="${labelX}" y="${labelY + 18}" font-size="8" font-weight="bold" fill="#0ea5e9" text-anchor="middle">Z:${p.z.toFixed(1)}</text>`;
                } else {
                    // Sub-point style
                    const subPointColor = getComputedStyle(document.documentElement).getPropertyValue('--sub-point-color').trim();
                    
                    svg += `<circle cx="${p.x}" cy="${p.y}" r="5" fill="${subPointColor}" stroke="#ffffff" stroke-width="1.5"/>`;

                    const labelX = p.x + p.labelOffsetX;
                    const labelY = p.y + p.labelOffsetY;
                    const labelWidth = 58; // Width for sub-point label box
                    const labelHeight = 30; // Height for sub-point label box
                    
                    // Shorten method name for display
                    const methodShort = p.method === 'Sudut+Jarak' ? 'Œ±+Œ¥' : p.method === 'Jarak' ? 'Œ¥' : 'Z';
                    
                    // Background box for sub-point label
                    svg += `<g>
                        <rect x="${labelX - labelWidth/2}" y="${labelY - labelHeight/2}" width="${labelWidth}" height="${labelHeight}" fill="rgba(16, 185, 129, 0.95)" stroke="${subPointColor}" stroke-width="1.5" rx="3"/>
                        <text x="${labelX}" y="${labelY - 6}" font-size="11" font-weight="bold" fill="#ffffff" text-anchor="middle">${p.name}</text>
                        <text x="${labelX}" y="${labelY + 4}" font-size="7" fill="#e0f2fe" text-anchor="middle">Z:${p.z.toFixed(1)}</text>
                        <text x="${labelX}" y="${labelY + 12}" font-size="6.5" fill="#ecfdf5" text-anchor="middle">${methodShort}</text>
                    </g>`;
                }
            });

            svg += `</svg>`;
            preview.innerHTML = svg;

            // Update the contour legend
            updateContourLegend(contourLevels, contourColors);
        }

        // Function to update the contour legend UI
        function updateContourLegend(levels, colors) {
            const legend = document.getElementById('contour-legend');
            const legendItems = document.getElementById('legend-items');
            
            if (!levels || levels.length === 0) {
                legend.style.display = 'none'; // Hide legend if no contours
                return;
            }

            legend.style.display = 'block'; // Show legend
            legendItems.innerHTML = levels.map((level, idx) => {
                const color = colors[idx % colors.length];
                return `<div class="contour-legend-item">
                    <div class="contour-legend-color" style="background-color: ${color};"></div>
                    <span>Z = ${level.toFixed(0)} m</span>
                </div>`;
            }).join('');
        }

        // Function to initialize the 3D visualization using Three.js
        function initialize3DVisualization() {
            const canvas = document.getElementById('canvas-3d');
            if (!canvas) return; // Exit if canvas element is not found

            canvas.classList.add('active'); // Make canvas visible

            // Clean up previous scene if it exists
            if (visualization3DScene) {
                visualization3DScene.traverse(function (object) {
                    if (object.geometry) object.geometry.dispose();
                    if (object.material) {
                        // Dispose materials properly, especially if they are complex
                        if (Array.isArray(object.material)) {
                            object.material.forEach(material => material.dispose());
                        } else {
                            object.material.dispose();
                        }
                    }
                });
                if (visualization3DRenderer) visualization3DRenderer.dispose();
                visualization3DScene = null;
                visualization3DRenderer = null;
                visualization3DCamera = null;
                visualization3DControls = null;
            }

            // Scene setup
            visualization3DScene = new THREE.Scene();
            
            // Get background color from CSS variables for theme consistency
            const bodyStyles = getComputedStyle(document.body);
            const bgColor = bodyStyles.getPropertyValue('--bg-primary').trim();
            visualization3DScene.background = new THREE.Color(bgColor);

            const width = canvas.clientWidth;
            const height = 400; // Fixed height for the canvas

            // Camera setup
            visualization3DCamera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);
            visualization3DCamera.position.set(0, 100, 100); // Initial camera position
            visualization3DCamera.lookAt(0, 0, 0); // Look at the origin

            // Renderer setup
            visualization3DRenderer = new THREE.WebGLRenderer({ canvas, antialias: true });
            visualization3DRenderer.setSize(width, height);
            visualization3DRenderer.setPixelRatio(window.devicePixelRatio); // For high-resolution displays

            // Add lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6); // Soft white light
            visualization3DScene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8); // Sun-like light
            directionalLight.position.set(100, 150, 100);
            visualization3DScene.add(directionalLight);

            // Create topographic surface mesh
            // Combine all points for mesh generation
            const allPoints = [...polygonMainPoints, ...polygonSubPoints].filter(p => !isNaN(p.x) && !isNaN(p.y) && !isNaN(p.z));
            
            if (allPoints.length >= 3) {
                const meshGeometry = new THREE.BufferGeometry();
                const vertices = [];
                const faces = [];

                // Normalize points for mesh generation (relative to a reference point)
                const refX = allPoints[0].x;
                const refY = allPoints[0].y;
                const zValues = allPoints.map(p => p.z);
                const minZ = Math.min(...zValues);
                const maxZ = Math.max(...zValues);
                const zRange = maxZ - minZ || 1; // Avoid division by zero

                // Scale points to fit within a reasonable 3D space
                const scaleFactor = 0.5; 
                const zScaleFactor = 30; 

                allPoints.forEach((point, idx) => {
                    const x = (point.x - refX) * scaleFactor;
                    const z = (point.y - refY) * scaleFactor; // Y coordinate maps to Z in 3D space
                    const y = (point.z - minZ) / zRange * zScaleFactor; // Normalized Z maps to Y in 3D space
                    vertices.push(x, y, z);
                });

                // Simple fan triangulation for demonstration. For complex terrains, Delaunay triangulation is better.
                if (vertices.length >= 9) { // Need at least 3 vertices for a triangle
                    for (let i = 0; i < vertices.length / 3 - 2; i++) {
                        faces.push(0, i + 1, i + 2);
                    }
                }

                meshGeometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array(vertices), 3));
                meshGeometry.setIndex(new THREE.BufferAttribute(new Uint32Array(faces), 1));
                meshGeometry.computeVertexNormals(); // Calculate normals for lighting

                // Material for the surface mesh
                const meshMaterial = new THREE.MeshPhongMaterial({
                    color: 0x3b82f6, // Base blue color
                    opacity: 0.7,
                    transparent: true,
                    flatShading: false, // Smooth shading
                    shininess: 30
                });

                const mesh = new THREE.Mesh(meshGeometry, meshMaterial);
                visualization3DScene.add(mesh);

                // Add wireframe for better visual definition
                const wireframe = new THREE.LineSegments(
                    new THREE.EdgesGeometry(meshGeometry), 
                    new THREE.LineBasicMaterial({ color: 0x0ea5e9, linewidth: 1 }) // Cyan wireframe
                );
                visualization3DScene.add(wireframe);
            }

            // Orbit Controls for camera manipulation
            visualization3DControls = new THREE.OrbitControls(visualization3DCamera, canvas);
            visualization3DControls.enableDamping = true; // Smooth camera movement
            visualization3DControls.dampingFactor = 0.25;
            visualization3DControls.screenSpacePanning = false;
            visualization3DControls.target.set(0, 0, 0); // Control target

            // Animation loop
            function animate() {
                requestAnimationFrame(animate);
                visualization3DControls.update(); // Update camera controls
                visualization3DRenderer.render(visualization3DScene, visualization3DCamera); // Render the scene
            }
            animate();

            // Handle window resizing
            window.addEventListener('resize', () => {
                const newWidth = canvas.clientWidth;
                const newHeight = 400; 
                visualization3DCamera.aspect = newWidth / newHeight;
                visualization3DCamera.updateProjectionMatrix();
                visualization3DRenderer.setSize(newWidth, newHeight);
            });
        }

        // Event listeners for surveyor tab clicks
        document.querySelectorAll('.surveyor-tab').forEach(tab => {
            tab.addEventListener('click', function() {
                document.querySelectorAll('.surveyor-tab').forEach(t => t.classList.remove('active'));
                this.classList.add('active');
                
                document.querySelectorAll('.surveyor-content').forEach(content => {
                    content.classList.add('hidden');
                });
                
                const targetId = this.getAttribute('data-tab') + '-calc';
                document.getElementById(targetId).classList.remove('hidden');
            });
        });

        // Function to switch between polygon input tabs (Main vs Sub Points)
        function switchPolygonTab(tabType) {
            const mainTab = document.getElementById('main-point-tab');
            const subTab = document.getElementById('sub-point-tab');
            const mainInput = document.getElementById('main-point-input');
            const subInput = document.getElementById('sub-point-input');

            if (tabType === 'main') {
                mainTab.classList.add('active');
                subTab.classList.remove('active');
                mainInput.classList.remove('hidden');
                subInput.classList.add('hidden');
            } else { // tabType === 'sub'
                mainTab.classList.remove('active');
                subTab.classList.add('active');
                mainInput.classList.add('hidden');
                subInput.classList.remove('hidden');
                updateSubPointDropdowns(); // Update dropdowns when sub-point tab is shown
            }
        }

        // Function to select the method for adding sub-points
        function selectSubMethod(method) {
            currentSubMethod = method;
            
            // Reset all method buttons to default style
            document.getElementById('method-angle').classList.remove('border-blue-500', 'bg-blue-50', 'text-blue-700');
            document.getElementById('method-angle').classList.add('border-gray-300', 'text-gray-700');
            document.getElementById('method-distance').classList.remove('border-blue-500', 'bg-blue-50', 'text-blue-700');
            document.getElementById('method-distance').classList.add('border-gray-300', 'text-gray-700');
            document.getElementById('method-height').classList.remove('border-blue-500', 'bg-blue-50', 'text-blue-700');
            document.getElementById('method-height').classList.add('border-gray-300', 'text-gray-700');
            
            // Apply active style to the selected method button
            document.getElementById(`method-${method}`).classList.add('border-blue-500', 'bg-blue-50', 'text-blue-700');
            
            // Hide all method input sections and show the selected one
            document.getElementById('method-angle-input').classList.add('hidden');
            document.getElementById('method-distance-input').classList.add('hidden');
            document.getElementById('method-height-input').classList.add('hidden');
            
            if (method === 'angle') {
                document.getElementById('method-angle-input').classList.remove('hidden');
                document.getElementById('angle-input-section').classList.remove('hidden');
                document.getElementById('distance-input-section').classList.add('hidden'); // Hide distance if only angle is selected
            } else if (method === 'distance') {
                document.getElementById('method-distance-input').classList.remove('hidden');
            } else if (method === 'height') {
                document.getElementById('method-height-input').classList.remove('hidden');
            }
        }

        // Function to add a main polygon point
        function addMainPoint() {
            const nameInput = document.querySelector('.polygon-main-name');
            const xInput = document.querySelector('.polygon-main-x');
            const yInput = document.querySelector('.polygon-main-y');
            const zInput = document.querySelector('.polygon-main-z');

            const name = nameInput.value.toUpperCase().trim();
            const x = parseFloat(xInput.value);
            const y = parseFloat(yInput.value);
            const z = parseFloat(zInput.value);

            // Input validation
            if (!name || !/^[A-Z]$/.test(name)) {
                showMessage('Nama titik utama harus huruf besar tunggal (A, B, C...)', 'error');
                return;
            }
            if (isNaN(x) || isNaN(y) || isNaN(z)) {
                showMessage('Koordinat X, Y, dan Z harus diisi dengan angka', 'error');
                return;
            }
            if (polygonMainPoints.find(p => p.name === name)) {
                showMessage(`Titik utama ${name} sudah ada`, 'error');
                return;
            }

            polygonMainPoints.push({ name, x, y, z });
            
            // Clear input fields
            nameInput.value = '';
            xInput.value = '';
            yInput.value = '';
            zInput.value = '';

            updateMainPointTable(); // Update table display
            updateSubPointDropdowns(); // Update dropdowns in sub-point section
            showMessage(`Titik utama ${name} (${x}, ${y}, ${z}) berhasil ditambahkan`, 'success');
        }

        // Function to add a sub polygon point based on the selected method
        function addSubPoint() {
            let subPoint = null; // Placeholder for the new sub-point data

            // Logic for each method
            if (currentSubMethod === 'angle') { // Angle + Distance method
                const mainPointSelect = document.querySelector('.polygon-sub-main');
                const nameInput = document.querySelector('.polygon-sub-name');
                const angleInput = document.querySelector('.polygon-sub-angle');
                const distanceInput = document.querySelector('.polygon-sub-distance');

                const mainPoint = mainPointSelect.value;
                const name = nameInput.value.trim();
                const angle = parseFloat(angleInput.value);
                const distance = parseFloat(distanceInput.value);

                // Input validation
                if (!mainPoint || !name || isNaN(angle) || isNaN(distance)) {
                    showMessage('Semua field harus diisi dengan benar', 'error');
                    return;
                }

                const mainPt = polygonMainPoints.find(p => p.name === mainPoint);
                if (!mainPt) {
                    showMessage('Titik utama tidak ditemukan', 'error'); // Should not happen if dropdown is correct
                    return;
                }

                // Calculate coordinates using polar to Cartesian conversion
                const rad = (angle * Math.PI) / 180; // Convert angle to radians
                const x = mainPt.x + distance * Math.sin(rad);
                const y = mainPt.y + distance * Math.cos(rad); // Assuming North is positive Y
                
                subPoint = { name, mainPoint, x, y, z: mainPt.z, method: 'Sudut+Jarak', angle, distance };

                // Clear input fields
                nameInput.value = '';
                angleInput.value = '';
                distanceInput.value = '';

            } else if (currentSubMethod === 'distance') { // Distance only method
                const mainPointSelect = document.querySelector('.polygon-sub-main-dist');
                const nameInput = document.querySelector('.polygon-sub-name-dist');
                const distanceInput = document.querySelector('.polygon-sub-distance-only');

                const mainPoint = mainPointSelect.value;
                const name = nameInput.value.trim();
                const distance = parseFloat(distanceInput.value);

                if (!mainPoint || !name || isNaN(distance)) {
                    showMessage('Semua field harus diisi dengan benar', 'error');
                    return;
                }

                const mainPt = polygonMainPoints.find(p => p.name === mainPoint);
                if (!mainPt) {
                    showMessage('Titik utama tidak ditemukan', 'error');
                    return;
                }

                // For distance-only, assume the new point lies on the same line from main point as the first main point
                // Or, a more sophisticated approach could use a default bearing, but for simplicity, we'll just place it at main point X,Y
                // NOTE: This is a simplification. A real-world scenario might need a bearing or direction.
                // For now, we'll just use the main point's X, Y and add the distance conceptually, but the calculation might need refinement.
                // A better approach would be to assume a default bearing (e.g., East, North) if only distance is given.
                // Here, we are assigning the main point's X, Y which is likely incorrect if the intent is to add distance *from* that point.
                // Let's refine this: Assume distance is along a line from main point, but we need a direction.
                // For simplicity, if only distance is provided, we'll assume it's *relative* and might need to be set manually or with a default direction.
                // A common approach: if distance is given without angle, it might imply a radial measurement.
                // For this implementation, let's assume it means a point *at* the main point's coordinates, and the distance is perhaps not directly calculable for X,Y.
                // A common interpretation: Add a point *along* a predefined bearing. Without that, we'll use a placeholder.
                // Let's assume distance represents how far *along the current segment* the point is, or a radial distance.
                // Given the lack of explicit direction, we'll assign placeholder X/Y for now.
                // A more robust solution would require an angle or reference point.
                // For now, we will compute X, Y based on the *first* segment's direction if possible, or default.

                // Placeholder calculation: If we have a previous segment, use its direction. Otherwise, assume East.
                let defaultBearing = 90; // East
                if (mainPt.azimuth !== undefined) { // If main point has calculated azimuth (meaning it's connected to a previous point)
                    defaultBearing = mainPt.azimuth; // Use the bearing towards this main point from the previous one.
                }
                const rad = (defaultBearing * Math.PI) / 180;
                const x = mainPt.x + distance * Math.sin(rad);
                const y = mainPt.y + distance * Math.cos(rad);

                subPoint = { name, mainPoint, x, y, z: mainPt.z, method: 'Jarak', distance };

                distanceInput.value = ''; // Clear field
                nameInput.value = '';

            } else if (currentSubMethod === 'height') { // Height only method
                const mainPointSelect = document.querySelector('.polygon-sub-main-height');
                const nameInput = document.querySelector('.polygon-sub-name-height');
                const zInput = document.querySelector('.polygon-sub-z-height');

                const mainPoint = mainPointSelect.value;
                const name = nameInput.value.trim();
                const z = parseFloat(zInput.value);

                if (!mainPoint || !name || isNaN(z)) {
                    showMessage('Semua field harus diisi dengan benar', 'error');
                    return;
                }

                const mainPt = polygonMainPoints.find(p => p.name === mainPoint);
                if (!mainPt) {
                    showMessage('Titik utama tidak ditemukan', 'error');
                    return;
                }

                // X and Y remain the same as the main point
                subPoint = { name, mainPoint, x: mainPt.x, y: mainPt.y, z, method: 'Tinggi' };

                nameInput.value = '';
                zInput.value = '';
            }

            // If subPoint data was successfully created
            if (!subPoint) return;

            // Check for duplicate sub-point names
            if (polygonSubPoints.find(p => p.name === subPoint.name)) {
                showMessage(`Titik turunan ${subPoint.name} sudah ada`, 'error');
                return;
            }

            polygonSubPoints.push(subPoint); // Add the new sub-point
            updateSubPointTable(); // Update the table display
            showMessage(`Titik turunan ${subPoint.name} (metode: ${subPoint.method}) berhasil ditambahkan`, 'success');
        }

        // Function to calculate polygon perimeter, area, and update results
        function calculatePolygon() {
            if (polygonMainPoints.length < 3) {
                showMessage('Minimal 3 titik utama diperlukan untuk membuat poligon', 'error');
                return;
            }

            let perimeter = 0;
            let area = 0; // Shoelace formula for area

            // Calculate area
            for (let i = 0; i < polygonMainPoints.length; i++) {
                const j = (i + 1) % polygonMainPoints.length; // Next point index, wraps around
                area += polygonMainPoints[i].x * polygonMainPoints[j].y;
                area -= polygonMainPoints[j].x * polygonMainPoints[i].y;
            }
            area = Math.abs(area) / 2; // Absolute value and divide by 2

            // Calculate perimeter and azimuth/distance for each main point segment
            for (let i = 0; i < polygonMainPoints.length; i++) {
                const j = (i + 1) % polygonMainPoints.length;
                const dx = polygonMainPoints[j].x - polygonMainPoints[i].x;
                const dy = polygonMainPoints[j].y - polygonMainPoints[i].y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                perimeter += distance;

                // Calculate azimuth (bearing from North, clockwise)
                let azimuth = Math.atan2(dx, dy) * 180 / Math.PI; // atan2(x, y) gives angle from positive Y axis (North)
                if (azimuth < 0) azimuth += 360; // Ensure azimuth is between 0 and 360 degrees

                polygonMainPoints[i].azimuth = azimuth;
                polygonMainPoints[i].distance = distance;
            }

            // Update result display
            document.getElementById('polygon-perimeter').textContent = perimeter.toFixed(2) + ' m';
            document.getElementById('polygon-area').textContent = area.toFixed(2) + ' m¬≤';
            document.getElementById('polygon-main-count').textContent = polygonMainPoints.length;
            document.getElementById('polygon-sub-count').textContent = polygonSubPoints.length;

            updateMainPointTable(); // Re-render main point table
            updateSubPointTable();   // Re-render sub point table
            
            // Update visualizations
            if (currentVisualizationMode === '2d') {
                drawPolygonPreviewWithEnhancedVisualization();
            } else {
                initialize3DVisualization(); // Ensure 3D view is updated
            }
            
            showMessage('Perhitungan poligon berhasil!', 'success');
        }

        // Update the main points table in the UI
        function updateMainPointTable() {
            const tbody = document.getElementById('polygon-main-table-body');
            if (polygonMainPoints.length === 0) {
                tbody.innerHTML = '<tr><td colspan="7" class="border border-gray-300 px-4 py-8 text-center text-gray-500">Belum ada titik utama</td></tr>';
                return;
            }

            tbody.innerHTML = polygonMainPoints.map((point, index) => `
                <tr>
                    <td class="border border-gray-300 px-3 py-2 font-bold text-red-600">${point.name}</td>
                    <td class="border border-gray-300 px-3 py-2 text-right">${point.x.toFixed(3)}</td>
                    <td class="border border-gray-300 px-3 py-2 text-right">${point.y.toFixed(3)}</td>
                    <td class="border border-gray-300 px-3 py-2 text-right font-semibold text-blue-600">${point.z.toFixed(3)}</td>
                    <td class="border border-gray-300 px-3 py-2 text-right">${point.azimuth !== undefined ? point.azimuth.toFixed(2) + '¬∞' : '-'}</td>
                    <td class="border border-gray-300 px-3 py-2 text-right">${point.distance !== undefined ? point.distance.toFixed(3) + ' m' : '-'}</td>
                    <td class="border border-gray-300 px-3 py-2 text-center">
                        <button onclick="removeMainPoint(${index})" class="text-red-500 hover:text-red-700 text-sm font-semibold">Hapus</button>
                    </td>
                </tr>
            `).join('');
        }

        // Update the sub points table in the UI
        function updateSubPointTable() {
            const tbody = document.getElementById('polygon-sub-table-body');
            if (polygonSubPoints.length === 0) {
                tbody.innerHTML = '<tr><td colspan="7" class="border border-gray-300 px-4 py-8 text-center text-gray-500">Belum ada titik turunan</td></tr>';
                return;
            }

            tbody.innerHTML = polygonSubPoints.map((point, index) => `
                <tr>
                    <td class="border border-gray-300 px-3 py-2 font-bold text-green-600">${point.name}</td>
                    <td class="border border-gray-300 px-3 py-2 text-red-600">${point.mainPoint}</td>
                    <td class="border border-gray-300 px-3 py-2 text-right">${point.x.toFixed(3)}</td>
                    <td class="border border-gray-300 px-3 py-2 text-right">${point.y.toFixed(3)}</td>
                    <td class="border border-gray-300 px-3 py-2 text-right font-semibold text-blue-600">${point.z.toFixed(3)}</td>
                    <td class="border border-gray-300 px-3 py-2 text-center text-xs bg-yellow-50">${point.method}</td>
                    <td class="border border-gray-300 px-3 py-2 text-center">
                        <button onclick="removeSubPoint(${index})" class="text-red-500 hover:text-red-700 text-sm font-semibold">Hapus</button>
                    </td>
                </tr>
            `).join('');
        }

        // Remove a main point and its associated sub-points
        function removeMainPoint(index) {
            const removedPoint = polygonMainPoints[index];
            polygonMainPoints.splice(index, 1);
            
            // Also remove any sub-points that belonged to this main point
            polygonSubPoints = polygonSubPoints.filter(p => p.mainPoint !== removedPoint.name);
            
            updateMainPointTable();
            updateSubPointTable();
            updateSubPointDropdowns(); // Update dropdowns as a main point was removed
            
            // Recalculate if enough points remain
            if (polygonMainPoints.length >= 3) {
                calculatePolygon();
            } else { // Reset results if fewer than 3 main points left
                document.getElementById('polygon-perimeter').textContent = '0.00 m';
                document.getElementById('polygon-area').textContent = '0.00 m¬≤';
                document.getElementById('polygon-main-count').textContent = polygonMainPoints.length;
                document.getElementById('polygon-sub-count').textContent = polygonSubPoints.length;
                document.getElementById('polygon-preview').innerHTML = '<p class="text-gray-500">Tambahkan minimal 3 titik utama untuk melihat preview</p>';
                document.getElementById('contour-legend').style.display = 'none';
            }
            showMessage(`Titik utama ${removedPoint.name} dan titik turunannya berhasil dihapus`, 'success');
        }

        // Remove a sub-point
        function removeSubPoint(index) {
            const removedPoint = polygonSubPoints[index];
            polygonSubPoints.splice(index, 1);
            updateSubPointTable();
            showMessage(`Titik turunan ${removedPoint.name} berhasil dihapus`, 'success');
        }

        // Helper function to calculate label offsets for collision avoidance
        function calculateLabelOffset(point, allPoints, allLabels, containerSize, isSubPoint = false) {
            const MIN_PADDING = isSubPoint ? 15 : 15; // Minimum desired separation between labels
            const baseOffset = isSubPoint ? 22 : 22; // Initial offset from point center
            const maxDistance = isSubPoint ? 65 : 70; // Max distance to search for a position
            
            let bestOffset = { offsetX: baseOffset, offsetY: -baseOffset }; // Default offset (top-left)
            let bestScore = Infinity; // Lower score is better
            
            // Try different angles around the point
            const angles = [];
            for (let i = 0; i < 16; i++) { // 16 angles, every 22.5 degrees
                angles.push((i * 22.5) * Math.PI / 180);
            }
            
            for (let angle of angles) {
                // Try different distances from the point
                for (let distance = baseOffset; distance <= maxDistance; distance += 3) {
                    const offsetX = distance * Math.cos(angle);
                    const offsetY = distance * Math.sin(angle);
                    
                    const labelWidth = isSubPoint ? 58 : 65;
                    const labelHeight = isSubPoint ? 30 : 40;
                    // Calculate the bounding box of the label at this offset
                    const labelRect = {
                        left: point.x + offsetX - labelWidth / 2,
                        right: point.x + offsetX + labelWidth / 2,
                        top: point.y + offsetY - labelHeight / 2,
                        bottom: point.y + offsetY + labelHeight / 2,
                        width: labelWidth,
                        height: labelHeight
                    };
                    
                    // Check if the label is within canvas bounds
                    const canvasPadding = 20;
                    if (labelRect.left < canvasPadding || labelRect.right > containerSize.width - canvasPadding ||
                        labelRect.top < canvasPadding || labelRect.bottom > containerSize.height - canvasPadding) {
                        continue; // Skip if out of bounds
                    }
                    
                    let overlapScore = 0; // Score for how much labels overlap
                    let minDistanceToAnyLabel = Infinity; // Minimum distance to any other label
                    let minDistanceToMainPoint = Infinity; // For sub-points, distance to their main point
                    
                    // Check for overlap with other labels
                    for (let otherLabel of allLabels) {
                        if (otherLabel === point) continue; // Don't check against itself
                        
                        // Special check for sub-points: penalize overlap with their main point
                        if (isSubPoint && otherLabel.name === point.mainPoint) {
                            const distX = Math.abs(labelRect.left + labelRect.width/2 - (otherLabel.x + (otherLabel.labelOffsetX || 0)));
                            const distY = Math.abs(labelRect.top + labelRect.height/2 - (otherLabel.y + (otherLabel.labelOffsetY || 0)));
                            const distToMain = Math.sqrt(distX * distX + distY * distY);
                            minDistanceToMainPoint = distToMain;
                            
                            if (distToMain < 15) { // If too close to main point
                                overlapScore += (15 - distToMain) * 8; // Penalize more heavily
                            }
                        }
                        
                        // Get dimensions of the other label
                        const otherWidth = otherLabel.isSubPoint ? 58 : 65;
                        const otherHeight = otherLabel.isSubPoint ? 30 : 40;
                        const otherRect = {
                            left: otherLabel.x + (otherLabel.labelOffsetX || 0) - otherWidth / 2,
                            right: otherLabel.x + (otherLabel.labelOffsetX || 0) + otherWidth / 2,
                            top: otherLabel.y + (otherLabel.labelOffsetY || 0) - otherHeight / 2,
                            bottom: otherLabel.y + (otherLabel.labelOffsetY || 0) + otherHeight / 2
                        };
                        
                        // Calculate distance between bounding boxes (perpendicular distance)
                        const distX = Math.max(0, 
                            labelRect.left > otherRect.right ? labelRect.left - otherRect.right : otherRect.left - labelRect.right
                        );
                        const distY = Math.max(0, 
                            labelRect.top > otherRect.bottom ? labelRect.top - otherRect.bottom : otherRect.top - labelRect.bottom
                        );
                        const perpendicularDist = Math.sqrt(distX * distX + distY * distY);
                        
                        minDistanceToAnyLabel = Math.min(minDistanceToAnyLabel, perpendicularDist);
                        
                        if (perpendicularDist < MIN_PADDING) { // If overlapping
                            overlapScore += (MIN_PADDING - perpendicularDist) * 6; // Penalize based on overlap amount
                        }
                        
                        // Calculate overlap area
                        const overlapWidth = Math.max(0, 
                            Math.min(labelRect.right, otherRect.right) - Math.max(labelRect.left, otherRect.left)
                        );
                        const overlapHeight = Math.max(0, 
                            Math.min(labelRect.bottom, otherRect.bottom) - Math.max(labelRect.top, otherRect.top)
                        );
                        const overlapArea = overlapWidth * overlapHeight;
                        overlapScore += overlapArea * 12; // Penalize more for larger overlap area
                    }
                    
                    // Score based on distance from the point center
                    const distFromNode = Math.sqrt(offsetX * offsetX + offsetY * offsetY);
                    const idealDist = isSubPoint ? 28 : 30; // Ideal distance from point for label placement
                    const distScore = Math.abs(distFromNode - idealDist) * 0.4; // Penalize deviation from ideal distance
                    
                    let score = overlapScore + distScore; // Total score
                    // Add additional penalties for being too close to the main point or other labels
                    if (!isSubPoint) {
                        score += Math.max(0, MIN_PADDING - minDistanceToAnyLabel) * 2;
                    } else {
                        score += Math.max(0, 15 - minDistanceToMainPoint) * 3;
                        score += Math.max(0, MIN_PADDING - minDistanceToAnyLabel) * 2.5;
                    }
                    
                    // If this position has a better score, update bestOffset
                    if (score < bestScore) {
                        bestScore = score;
                        bestOffset = { offsetX, offsetY };
                    }
                }
            }
            
            return bestOffset; // Return the offset that resulted in the lowest score
        }

        // Sample data for different modules
        const sampleData = {
            polygonMain: [
                { name: 'A', x: 100.000, y: 200.000, z: 105.5 },
                { name: 'B', x: 150.000, y: 200.000, z: 106.2 },
                { name: 'C', x: 150.000, y: 250.000, z: 107.1 },
                { name: 'D', x: 120.000, y: 270.000, z: 108.0 },
                { name: 'E', x: 100.000, y: 250.000, z: 106.8 }
            ],
            polygonSub: [
                { name: 'a1', mainPoint: 'A', x: 102.5, y: 201.2, z: 105.8, method: 'Sudut+Jarak', angle: 45, distance: 3.5 },
                { name: 'a2', mainPoint: 'A', x: 100.000, y: 200.000, z: 106.1, method: 'Tinggi' }, // Note: X,Y same as main, only Z changes
                { name: 'b1', mainPoint: 'B', x: 150.000, y: 200.000, z: 106.5, method: 'Tinggi' },
                { name: 'c1', mainPoint: 'C', x: 150.000, y: 250.000, z: 107.4, method: 'Tinggi' },
                { name: 'c2', mainPoint: 'C', x: 150.000, y: 250.000, z: 107.3, method: 'Tinggi' },
                { name: 'd1', mainPoint: 'D', x: 120.000, y: 270.000, z: 108.2, method: 'Tinggi' },
                { name: 'e1', mainPoint: 'E', x: 100.000, y: 250.000, z: 107.0, method: 'Tinggi' }
            ],
            grid: [
                { name: 'G1', x: 100, y: 100, z: 105.2 },
                { name: 'G2', x: 110, y: 100, z: 105.8 },
                { name: 'G3', x: 120, y: 100, z: 106.1 },
                { name: 'G4', x: 100, y: 110, z: 105.5 },
                { name: 'G5', x: 110, y: 110, z: 106.0 },
                { name: 'G6', x: 120, y: 110, z: 106.3 }
            ],
            profile: [
                { name: 'P1', distance: 0, elevation: 105.0 },
                { name: 'P2', distance: 25, elevation: 106.2 },
                { name: 'P3', distance: 50, elevation: 107.8 },
                { name: 'P4', distance: 75, elevation: 108.5 },
                { name: 'P5', distance: 100, elevation: 109.1 }
            ],
            random: [
                { name: 'R1', x: 95, y: 205, z: 105.3 },
                { name: 'R2', x: 132, y: 187, z: 106.7 },
                { name: 'R3', x: 168, y: 234, z: 107.2 },
                { name: 'R4', x: 143, y: 276, z: 108.1 },
                { name: 'R5', x: 89, y: 251, z: 106.9 }
            ]
        };

        // Load sample data into the respective modules
        function loadSampleData(module) {
            if (module === 'polygon') {
                polygonMainPoints = JSON.parse(JSON.stringify(sampleData.polygonMain)); // Deep copy
                polygonSubPoints = JSON.parse(JSON.stringify(sampleData.polygonSub));
                
                updateMainPointTable();
                updateSubPointTable();
                updateSubPointDropdowns();
                calculatePolygon();
                
                showMessage('Data contoh berhasil dimuat! 5 titik utama + 7 titik turunan siap dihitung.', 'success');
            } else if (module === 'grid') {
                gridPoints = JSON.parse(JSON.stringify(sampleData.grid));
                updateGridTable();
                calculateGrid();
                showMessage('Data contoh grid berhasil dimuat!', 'success');
            } else if (module === 'profile') {
                profilePoints = JSON.parse(JSON.stringify(sampleData.profile));
                updateProfileTable();
                calculateProfile();
                showMessage('Data contoh profil berhasil dimuat!', 'success');
            } else if (module === 'random') {
                randomPoints = JSON.parse(JSON.stringify(sampleData.random));
                updateRandomTable();
                calculateRandom();
                showMessage('Data contoh titik acak berhasil dimuat!', 'success');
            }
        }

        // Clear all data from a specific module
        function clearData(module) {
            if (module === 'polygon') {
                polygonMainPoints = [];
                polygonSubPoints = [];
                updateMainPointTable();
                updateSubPointTable();
                updateSubPointDropdowns();
                // Reset results and preview
                document.getElementById('polygon-perimeter').textContent = '0.00 m';
                document.getElementById('polygon-area').textContent = '0.00 m¬≤';
                document.getElementById('polygon-main-count').textContent = '0';
                document.getElementById('polygon-sub-count').textContent = '0';
                document.getElementById('polygon-preview').innerHTML = '<p class="text-gray-500">Tambahkan minimal 3 titik utama untuk melihat preview</p>';
                document.getElementById('contour-legend').style.display = 'none';
                showMessage('Semua data poligon berhasil dihapus', 'success');
            } else if (module === 'grid') {
                gridPoints = [];
                updateGridTable();
                // Reset results
                document.getElementById('grid-count').textContent = '0';
                document.getElementById('grid-avg-elevation').textContent = '0.00 m';
                document.getElementById('grid-elevation-range').textContent = '0.00 m';
                document.getElementById('grid-preview').innerHTML = '<p class="text-gray-500">Tambahkan titik grid untuk melihat preview</p>';
                showMessage('Semua data grid berhasil dihapus', 'success');
            } else if (module === 'profile') {
                profilePoints = [];
                updateProfileTable();
                // Reset results
                document.getElementById('profile-total-distance').textContent = '0.00 m';
                document.getElementById('profile-avg-slope').textContent = '0.00%';
                document.getElementById('profile-max-elevation').textContent = '0.00 m';
                document.getElementById('profile-min-elevation').textContent = '0.00 m';
                document.getElementById('profile-chart').innerHTML = '<p class="text-gray-500">Tambahkan titik profil untuk melihat grafik</p>';
                showMessage('Semua data profil berhasil dihapus', 'success');
            } else if (module === 'random') {
                randomPoints = [];
                updateRandomTable();
                // Reset results
                document.getElementById('random-count').textContent = '0';
                document.getElementById('random-avg-distance').textContent = '0.00 m';
                document.getElementById('random-area').textContent = '0.00 m¬≤';
                document.getElementById('random-preview').innerHTML = '<p class="text-gray-500">Tambahkan titik acak untuk melihat sebaran</p>';
                showMessage('Semua data titik acak berhasil dihapus', 'success');
            }
        }

        // Export data from grid, profile, or random modules
        function exportData(module, format) {
            let data, filename;
            
            // Select data based on module
            if (module === 'grid') {
                if (gridPoints.length === 0) { showMessage('Tidak ada data grid untuk diekspor', 'error'); return; }
                data = gridPoints;
                filename = 'grid_data';
            } else if (module === 'profile') {
                if (profilePoints.length === 0) { showMessage('Tidak ada data profil untuk diekspor', 'error'); return; }
                data = profilePoints;
                filename = 'profile_data';
            } else if (module === 'random') {
                if (randomPoints.length === 0) { showMessage('Tidak ada data titik acak untuk diekspor', 'error'); return; }
                data = randomPoints;
                filename = 'random_points_data';
            }

            // Generate content based on format
            if (format === 'csv') {
                let content = '';
                if (module === 'grid' || module === 'random') {
                    content = 'Nama,X,Y,Z\n';
                    content += data.map(p => `${p.name},${p.x},${p.y},${p.z}`).join('\n');
                } else if (module === 'profile') {
                    content = 'Nama,Jarak,Elevasi,Kemiringan\n';
                    // Calculate slope if it exists, otherwise leave blank
                    content += data.map(p => `${p.name},${p.distance},${p.elevation},${p.slope !== undefined ? p.slope.toFixed(2) : ''}`).join('\n');
                }
                
                downloadFile(content, filename + '.csv', 'text/csv');
                showMessage(`Data ${module} berhasil diekspor dalam format CSV`, 'success');
            }
        }

        // Export polygon data (both main and sub points) in CSV or JSON format
        function exportPolygonData(format) {
            if (polygonMainPoints.length === 0 && polygonSubPoints.length === 0) {
                showMessage('Tidak ada data untuk diekspor', 'error');
                return;
            }

            let content, filename, mimeType;

            if (format === 'csv') {
                // CSV format: Type,Name,MainPoint,X,Y,Z,Azimuth,Distance,Method
                content = 'Tipe,Nama,TitikUtama,X,Y,Z,Azimuth,Jarak,Metode\n';
                
                // Add main points
                polygonMainPoints.forEach(p => {
                    content += `Utama,${p.name},,${p.x},${p.y},${p.z},${p.azimuth !== undefined ? p.azimuth.toFixed(2) : ''},${p.distance !== undefined ? p.distance.toFixed(3) : ''},\n`;
                });
                
                // Add sub points
                polygonSubPoints.forEach(p => {
                    content += `Turunan,${p.name},${p.mainPoint},${p.x},${p.y},${p.z},,${p.method}\n`;
                });
                
                filename = 'polygon_data_complete.csv';
                mimeType = 'text/csv';
            } else if (format === 'json') {
                // JSON format: structured data
                content = JSON.stringify({
                    mainPoints: polygonMainPoints,
                    subPoints: polygonSubPoints,
                    metadata: { // Include summary info
                        totalMainPoints: polygonMainPoints.length,
                        totalSubPoints: polygonSubPoints.length,
                        exportDate: new Date().toISOString()
                    }
                }, null, 2); // Pretty print JSON
                filename = 'polygon_data_complete.json';
                mimeType = 'application/json';
            }

            downloadFile(content, filename, mimeType);
            showMessage(`Data polygon berhasil diekspor dalam format ${format.toUpperCase()}`, 'success');
        }

        // Helper function to display temporary messages (e.g., success, error)
        function showMessage(text, type = 'info') {
            const message = document.createElement('div');
            message.className = `fixed top-20 right-4 px-6 py-3 rounded-lg shadow-lg z-50 transition-all duration-300 ease-in-out ${
                type === 'error' ? 'bg-red-100 border border-red-400 text-red-700' :
                type === 'success' ? 'bg-green-100 border border-green-400 text-green-700' :
                'bg-blue-100 border border-blue-400 text-blue-700'
            }`;
            message.textContent = text;
            document.body.appendChild(message);
            // Remove message after a few seconds
            setTimeout(() => {
                message.style.opacity = '0'; // Fade out
                message.addEventListener('transitionend', () => message.remove());
            }, 4000);
        }

        // Helper function to trigger file download
        function downloadFile(content, filename, mimeType) {
            const blob = new Blob([content], { type: mimeType });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a); // Clean up the link element
            URL.revokeObjectURL(url); // Release the object URL
        }

        // Add a new point to the grid
        function addGridPoint() {
            const nameInput = document.querySelector('.grid-name');
            const xInput = document.querySelector('.grid-x');
            const yInput = document.querySelector('.grid-y');
            const zInput = document.querySelector('.grid-z');

            const name = nameInput.value.trim();
            const x = parseFloat(xInput.value);
            const y = parseFloat(yInput.value);
            const z = parseFloat(zInput.value);

            // Validation
            if (!name || isNaN(x) || isNaN(y) || isNaN(z)) {
                showMessage('Semua field harus diisi dengan benar', 'error');
                return;
            }
            if (gridPoints.find(p => p.name === name)) {
                showMessage(`Titik ${name} sudah ada`, 'error');
                return;
            }

            gridPoints.push({ name, x, y, z });
            
            // Clear inputs
            nameInput.value = '';
            xInput.value = '';
            yInput.value = '';
            zInput.value = '';

            updateGridTable();
            showMessage(`Titik grid ${name} berhasil ditambahkan`, 'success');
        }

        // Calculate grid statistics and update UI
        function calculateGrid() {
            if (gridPoints.length === 0) {
                showMessage('Belum ada data grid untuk dihitung', 'error');
                return;
            }

            const elevations = gridPoints.map(p => p.z);
            const avgElevation = elevations.reduce((a, b) => a + b, 0) / elevations.length;
            const minElevation = Math.min(...elevations);
            const maxElevation = Math.max(...elevations);
            const elevationRange = maxElevation - minElevation;

            // Update summary statistics
            document.getElementById('grid-count').textContent = gridPoints.length;
            document.getElementById('grid-avg-elevation').textContent = avgElevation.toFixed(2) + ' m';
            document.getElementById('grid-elevation-range').textContent = elevationRange.toFixed(2) + ' m';

            updateGridTable();
            drawGridPreview(); // Redraw preview
            showMessage('Perhitungan grid berhasil!', 'success');
        }

        // Update the grid points table
        function updateGridTable() {
            const tbody = document.getElementById('grid-table-body');
            if (gridPoints.length === 0) {
                tbody.innerHTML = '<tr><td colspan="5" class="border border-gray-300 px-4 py-8 text-center text-gray-500">Belum ada data grid</td></tr>';
                return;
            }

            tbody.innerHTML = gridPoints.map((point, index) => `
                <tr>
                    <td class="border border-gray-300 px-4 py-2 font-bold">${point.name}</td>
                    <td class="border border-gray-300 px-4 py-2 text-right">${point.x.toFixed(3)}</td>
                    <td class="border border-gray-300 px-4 py-2 text-right">${point.y.toFixed(3)}</td>
                    <td class="border border-gray-300 px-4 py-2 text-right">${point.z.toFixed(3)}</td>
                    <td class="border border-gray-300 px-4 py-2 text-center">
                        <button onclick="removeGridPoint(${index})" class="text-red-500 hover:text-red-700">Hapus</button>
                    </td>
                </tr>
            `).join('');
        }

        // Remove a grid point
        function removeGridPoint(index) {
            const removedPoint = gridPoints[index];
            gridPoints.splice(index, 1);
            updateGridTable();
            // Recalculate if points remain, otherwise reset
            if (gridPoints.length > 0) calculateGrid();
            else { 
                document.getElementById('grid-count').textContent = '0';
                document.getElementById('grid-avg-elevation').textContent = '0.00 m';
                document.getElementById('grid-elevation-range').textContent = '0.00 m';
                document.getElementById('grid-preview').innerHTML = '<p class="text-gray-500">Tambahkan titik grid untuk melihat preview</p>';
            }
            showMessage(`Titik grid ${removedPoint.name} berhasil dihapus`, 'success');
        }

        // Draw the grid preview on the canvas
        function drawGridPreview() {
            const preview = document.getElementById('grid-preview');
            if (gridPoints.length === 0) {
                preview.innerHTML = '<p class="text-gray-500">Tambahkan titik grid untuk melihat preview</p>';
                return;
            }

            // Determine bounds and scaling for the SVG
            const minX = Math.min(...gridPoints.map(p => p.x));
            const maxX = Math.max(...gridPoints.map(p => p.x));
            const minY = Math.min(...gridPoints.map(p => p.y));
            const maxY = Math.max(...gridPoints.map(p => p.y));
            
            const width = 400;
            const height = 250;
            const padding = 20;
            
            const scaleX = (width - 2 * padding) / (maxX - minX || 1);
            const scaleY = (height - 2 * padding) / (maxY - minY || 1);
            const scale = Math.min(scaleX, scaleY);

            // Generate SVG elements for each point
            preview.innerHTML = `
                <svg width="100%" height="100%" viewBox="0 0 ${width} ${height}" class="border rounded">
                    ${gridPoints.map(p => {
                        const x = padding + (p.x - minX) * scale;
                        const y = height - padding - (p.y - minY) * scale; // Invert Y for SVG
                        return `<circle cx="${x}" cy="${y}" r="4" fill="#3b82f6"/>
                                <text x="${x + 8}" y="${y - 8}" font-size="10" font-weight="bold" fill="#374151">${p.name}</text>
                                <text x="${x + 8}" y="${y + 5}" font-size="8" fill="#6b7280">Z:${p.z.toFixed(1)}</text>`;
                    }).join('')}
                </svg>
            `;
        }

        // Add a new point to the profile data
        function addProfilePoint() {
            const nameInput = document.querySelector('.profile-name');
            const distanceInput = document.querySelector('.profile-distance');
            const elevationInput = document.querySelector('.profile-elevation');

            const name = nameInput.value.trim();
            const distance = parseFloat(distanceInput.value);
            const elevation = parseFloat(elevationInput.value);

            // Validation
            if (!name || isNaN(distance) || isNaN(elevation)) {
                showMessage('Semua field harus diisi dengan benar', 'error');
                return;
            }
            if (profilePoints.find(p => p.name === name)) {
                showMessage(`Titik ${name} sudah ada`, 'error');
                return;
            }

            profilePoints.push({ name, distance, elevation });
            profilePoints.sort((a, b) => a.distance - b.distance); // Keep points sorted by distance
            
            // Clear inputs
            nameInput.value = '';
            distanceInput.value = '';
            elevationInput.value = '';

            updateProfileTable();
            showMessage(`Titik profil ${name} berhasil ditambahkan`, 'success');
        }

        // Calculate profile statistics (total distance, average slope, elevation range)
        function calculateProfile() {
            if (profilePoints.length === 0) {
                showMessage('Belum ada data profil untuk dihitung', 'error');
                return;
            }

            // Total distance is the distance of the last point
            const totalDistance = profilePoints.length > 0 ? profilePoints[profilePoints.length - 1].distance : 0;
            const elevations = profilePoints.map(p => p.elevation);
            const minElevation = Math.min(...elevations);
            const maxElevation = Math.max(...elevations);

            // Calculate slope for each segment
            for (let i = 0; i < profilePoints.length; i++) {
                if (i > 0) {
                    const prevPoint = profilePoints[i - 1];
                    const currPoint = profilePoints[i];
                    const deltaH = currPoint.elevation - prevPoint.elevation;
                    const deltaD = currPoint.distance - prevPoint.distance;
                    currPoint.slope = deltaD > 0 ? (deltaH / deltaD) * 100 : 0; // Slope in percentage
                } else {
                    profilePoints[i].slope = 0; // Slope is 0 for the first point
                }
            }

            // Calculate average slope (excluding the first point's 0 slope)
            const avgSlope = profilePoints.length > 1 ? 
                profilePoints.slice(1).reduce((sum, p) => sum + (p.slope || 0), 0) / (profilePoints.length - 1) : 0;

            // Update summary statistics
            document.getElementById('profile-total-distance').textContent = totalDistance.toFixed(2) + ' m';
            document.getElementById('profile-avg-slope').textContent = avgSlope.toFixed(2) + '%';
            document.getElementById('profile-max-elevation').textContent = maxElevation.toFixed(2) + ' m';
            document.getElementById('profile-min-elevation').textContent = minElevation.toFixed(2) + ' m';

            updateProfileTable();
            drawProfileChart(); // Redraw chart
            showMessage('Perhitungan profil berhasil!', 'success');
        }

        // Update the profile points table
        function updateProfileTable() {
            const tbody = document.getElementById('profile-table-body');
            if (profilePoints.length === 0) {
                tbody.innerHTML = '<tr><td colspan="5" class="border border-gray-300 px-4 py-8 text-center text-gray-500">Belum ada data profil</td></tr>';
                return;
            }

            tbody.innerHTML = profilePoints.map((point, index) => `
                <tr>
                    <td class="border border-gray-300 px-4 py-2 font-bold">${point.name}</td>
                    <td class="border border-gray-300 px-4 py-2 text-right">${point.distance.toFixed(3)}</td>
                    <td class="border border-gray-300 px-4 py-2 text-right">${point.elevation.toFixed(3)}</td>
                    <td class="border border-gray-300 px-4 py-2 text-right">${point.slope !== undefined ? point.slope.toFixed(2) + '%' : '-'}</td>
                    <td class="border border-gray-300 px-4 py-2 text-center">
                        <button onclick="removeProfilePoint(${index})" class="text-red-500 hover:text-red-700">Hapus</button>
                    </td>
                </tr>
            `).join('');
        }

        // Remove a profile point
        function removeProfilePoint(index) {
            const removedPoint = profilePoints[index];
            profilePoints.splice(index, 1);
            updateProfileTable();
            // Recalculate if points remain, otherwise reset
            if (profilePoints.length > 0) calculateProfile();
            else { 
                document.getElementById('profile-total-distance').textContent = '0.00 m';
                document.getElementById('profile-avg-slope').textContent = '0.00%';
                document.getElementById('profile-max-elevation').textContent = '0.00 m';
                document.getElementById('profile-min-elevation').textContent = '0.00 m';
                document.getElementById('profile-chart').innerHTML = '<p class="text-gray-500">Tambahkan titik profil untuk melihat grafik</p>';
            }
            showMessage(`Titik profil ${removedPoint.name} berhasil dihapus`, 'success');
        }

        // Draw the profile chart on the canvas
        function drawProfileChart() {
            const chart = document.getElementById('profile-chart');
            if (profilePoints.length === 0) {
                chart.innerHTML = '<p class="text-gray-500">Tambahkan titik profil untuk melihat grafik</p>';
                return;
            }

            // Determine bounds and scaling for the SVG chart
            const width = 400;
            const height = 250;
            const padding = 40; // Padding for axes and labels
            
            const maxDistance = profilePoints.length > 0 ? profilePoints[profilePoints.length - 1].distance : 1;
            const elevations = profilePoints.map(p => p.elevation);
            const minElevation = Math.min(...elevations);
            const maxElevation = Math.max(...elevations);
            const elevationRange = maxElevation - minElevation || 1; // Avoid division by zero

            const scaleX = (width - 2 * padding) / maxDistance;
            const scaleY = (height - 2 * padding) / elevationRange;

            // Generate SVG path for the profile line
            const pathData = profilePoints.map((p, i) => {
                const x = padding + p.distance * scaleX;
                const y = height - padding - (p.elevation - minElevation) * scaleY; // Invert Y for SVG
                return `${i === 0 ? 'M' : 'L'} ${x} ${y}`;
            }).join(' ');

            // Generate SVG elements for the chart
            chart.innerHTML = `
                <svg width="100%" height="100%" viewBox="0 0 ${width} ${height}" class="border rounded">
                    <!-- Axes -->
                    <line x1="${padding}" y1="${height - padding}" x2="${width - padding}" y2="${height - padding}" stroke="#9ca3af" stroke-width="1"/> <!-- X-axis -->
                    <line x1="${padding}" y1="${height - padding}" x2="${padding}" y2="${padding}" stroke="#9ca3af" stroke-width="1"/> <!-- Y-axis -->
                    
                    <!-- Profile Line -->
                    <path d="${pathData}" fill="none" stroke="#3b82f6" stroke-width="2"/>
                    
                    <!-- Points and Labels -->
                    ${profilePoints.map(p => {
                        const x = padding + p.distance * scaleX;
                        const y = height - padding - (p.elevation - minElevation) * scaleY;
                        return `<circle cx="${x}" cy="${y}" r="3" fill="#ef4444"/>
                                <text x="${x}" y="${y - 8}" font-size="8" text-anchor="middle" fill="#374151">${p.name}</text>`;
                    }).join('')}
                </svg>
            `;
        }

        // Add a new random point
        function addRandomPoint() {
            const nameInput = document.querySelector('.random-name');
            const xInput = document.querySelector('.random-x');
            const yInput = document.querySelector('.random-y');
            const zInput = document.querySelector('.random-z');

            const name = nameInput.value.trim();
            const x = parseFloat(xInput.value);
            const y = parseFloat(yInput.value);
            const z = parseFloat(zInput.value);

            // Validation
            if (!name || isNaN(x) || isNaN(y) || isNaN(z)) {
                showMessage('Semua field harus diisi dengan benar', 'error');
                return;
            }
            if (randomPoints.find(p => p.name === name)) {
                showMessage(`Titik ${name} sudah ada`, 'error');
                return;
            }

            randomPoints.push({ name, x, y, z });
            
            // Clear inputs
            nameInput.value = '';
            xInput.value = '';
            yInput.value = '';
            zInput.value = '';

            updateRandomTable();
            showMessage(`Titik acak ${name} berhasil ditambahkan`, 'success');
        }

        // Calculate statistics for random points (centroid, average distance, area)
        function calculateRandom() {
            if (randomPoints.length === 0) {
                showMessage('Belum ada titik acak untuk dianalisis', 'error');
                return;
            }

            // Calculate centroid
            const centroidX = randomPoints.reduce((sum, p) => sum + p.x, 0) / randomPoints.length;
            const centroidY = randomPoints.reduce((sum, p) => sum + p.y, 0) / randomPoints.length;

            // Calculate distance of each point to the centroid
            randomPoints.forEach(point => {
                const dx = point.x - centroidX;
                const dy = point.y - centroidY;
                point.distanceToCenter = Math.sqrt(dx * dx + dy * dy);
            });

            // Calculate average distance
            const avgDistance = randomPoints.reduce((sum, p) => sum + p.distanceToCenter, 0) / randomPoints.length;

            // Calculate the bounding box area
            const minX = Math.min(...randomPoints.map(p => p.x));
            const maxX = Math.max(...randomPoints.map(p => p.x));
            const minY = Math.min(...randomPoints.map(p => p.y));
            const maxY = Math.max(...randomPoints.map(p => p.y));
            const area = (maxX - minX) * (maxY - minY);

            // Update summary statistics
            document.getElementById('random-count').textContent = randomPoints.length;
            document.getElementById('random-avg-distance').textContent = avgDistance.toFixed(2) + ' m';
            document.getElementById('random-area').textContent = area.toFixed(2) + ' m¬≤';

            updateRandomTable();
            drawRandomPreview(); // Redraw preview
            showMessage('Analisis titik acak berhasil!', 'success');
        }

        // Update the random points table
        function updateRandomTable() {
            const tbody = document.getElementById('random-table-body');
            if (randomPoints.length === 0) {
                tbody.innerHTML = '<tr><td colspan="6" class="border border-gray-300 px-4 py-8 text-center text-gray-500">Belum ada titik acak</td></tr>';
                return;
            }

            tbody.innerHTML = randomPoints.map((point, index) => `
                <tr>
                    <td class="border border-gray-300 px-4 py-2 font-bold">${point.name}</td>
                    <td class="border border-gray-300 px-4 py-2 text-right">${point.x.toFixed(3)}</td>
                    <td class="border border-gray-300 px-4 py-2 text-right">${point.y.toFixed(3)}</td>
                    <td class="border border-gray-300 px-4 py-2 text-right">${point.z.toFixed(3)}</td>
                    <td class="border border-gray-300 px-4 py-2 text-right">${point.distanceToCenter !== undefined ? point.distanceToCenter.toFixed(2) : '-'}</td>
                    <td class="border border-gray-300 px-4 py-2 text-center">
                        <button onclick="removeRandomPoint(${index})" class="text-red-500 hover:text-red-700">Hapus</button>
                    </td>
                </tr>
            `).join('');
        }

        // Remove a random point
        function removeRandomPoint(index) {
            const removedPoint = randomPoints[index];
            randomPoints.splice(index, 1);
            updateRandomTable();
            // Recalculate if points remain, otherwise reset
            if (randomPoints.length > 0) calculateRandom();
            else { 
                document.getElementById('random-count').textContent = '0';
                document.getElementById('random-avg-distance').textContent = '0.00 m';
                document.getElementById('random-area').textContent = '0.00 m¬≤';
                document.getElementById('random-preview').innerHTML = '<p class="text-gray-500">Tambahkan titik acak untuk melihat sebaran</p>';
            }
            showMessage(`Titik acak ${removedPoint.name} berhasil dihapus`, 'success');
        }

        // Draw the random points preview on the canvas
        function drawRandomPreview() {
            const preview = document.getElementById('random-preview');
            if (randomPoints.length === 0) {
                preview.innerHTML = '<p class="text-gray-500">Tambahkan titik acak untuk melihat sebaran</p>';
                return;
            }

            // Determine bounds and scaling for the SVG preview
            const minX = Math.min(...randomPoints.map(p => p.x));
            const maxX = Math.max(...randomPoints.map(p => p.x));
            const minY = Math.min(...randomPoints.map(p => p.y));
            const maxY = Math.max(...randomPoints.map(p => p.y));
            
            const width = 400;
            const height = 250;
            const padding = 20;
            
            const scaleX = (width - 2 * padding) / (maxX - minX || 1);
            const scaleY = (height - 2 * padding) / (maxY - minY || 1);
            const scale = Math.min(scaleX, scaleY);

            // Calculate centroid position
            const centroidX = randomPoints.reduce((sum, p) => sum + p.x, 0) / randomPoints.length;
            const centroidY = randomPoints.reduce((sum, p) => sum + p.y, 0) / randomPoints.length;
            const centX = padding + (centroidX - minX) * scale;
            const centY = height - padding - (centroidY - minY) * scale;

            // Generate SVG elements for points, centroid, and lines
            preview.innerHTML = `
                <svg width="100%" height="100%" viewBox="0 0 ${width} ${height}" class="border rounded">
                    <!-- Centroid -->
                    <circle cx="${centX}" cy="${centY}" r="6" fill="#ef4444" stroke="#ffffff" stroke-width="2"/>
                    <text x="${centX + 10}" y="${centY - 10}" font-size="10" font-weight="bold" fill="#ef4444">Pusat</text>
                    
                    <!-- Random Points -->
                    ${randomPoints.map(p => {
                        const x = padding + (p.x - minX) * scale;
                        const y = height - padding - (p.y - minY) * scale;
                        return `<circle cx="${x}" cy="${y}" r="4" fill="#3b82f6"/>
                                <line x1="${centX}" y1="${centY}" x2="${x}" y2="${y}" stroke="#94a3b8" stroke-width="1" stroke-dasharray="2,2"/> <!-- Line to centroid -->
                                <text x="${x + 8}" y="${y - 8}" font-size="8" font-weight="bold" fill="#374151">${p.name}</text>`;
                    }).join('')}
                </svg>
            `;
        }
        
        // Update sub-point dropdowns with main points
        function updateSubPointDropdowns() {
            const mainPointSelects = [
                document.querySelector('.polygon-sub-main'),
                document.querySelector('.polygon-sub-main-dist'),
                document.querySelector('.polygon-sub-main-height')
            ];

            const optionsHtml = polygonMainPoints.map(p => `<option value="${p.name}">${p.name}</option>`).join('');

            mainPointSelects.forEach(select => {
                if (select) {
                    select.innerHTML = `<option value="">Pilih Titik Utama</option>${optionsHtml}`;
                }
            });
        }
    </script>
 </body>
</html>

